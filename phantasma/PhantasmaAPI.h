//THIS FILE IS AUTOMATICALLY GENERATED. DO NOT PERFORM MANUAL MAINTENANCE HERE.
#pragma once
#ifndef PHANTASMA_API_INCLUDED
#define PHANTASMA_API_INCLUDED
//------------------------------------------------------------------------------
// Low-level API
//------------------------------------------------------------------------------
//  The PhantasmaJsonAPI namespace can construct JSON requests and parse JSON responses,
//   but you are responsible for sending/receiving these messages via HTTP on your own.
//   You can call `PhantasmaJsonAPI::Uri()` to determine where to send them.
//
//     void PhantasmaJsonAPI::MakeGetAccountRequest(JSONBuilder, account);
//     bool PhantasmaJsonAPI::ParseGetAccountResponse(JSONValue, Account);
//     void PhantasmaJsonAPI::MakeLookUpNameRequest(JSONBuilder, name);
//     bool PhantasmaJsonAPI::ParseLookUpNameResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeGetBlockHeightRequest(JSONBuilder, chainInput);
//     bool PhantasmaJsonAPI::ParseGetBlockHeightResponse(JSONValue, Int32);
//     void PhantasmaJsonAPI::MakeGetBlockTransactionCountByHashRequest(JSONBuilder, blockHash);
//     bool PhantasmaJsonAPI::ParseGetBlockTransactionCountByHashResponse(JSONValue, Int32);
//     void PhantasmaJsonAPI::MakeGetBlockByHashRequest(JSONBuilder, blockHash);
//     bool PhantasmaJsonAPI::ParseGetBlockByHashResponse(JSONValue, Block);
//     void PhantasmaJsonAPI::MakeGetRawBlockByHashRequest(JSONBuilder, blockHash);
//     bool PhantasmaJsonAPI::ParseGetRawBlockByHashResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeGetBlockByHeightRequest(JSONBuilder, chainInput, height);
//     bool PhantasmaJsonAPI::ParseGetBlockByHeightResponse(JSONValue, Block);
//     void PhantasmaJsonAPI::MakeGetRawBlockByHeightRequest(JSONBuilder, chainInput, height);
//     bool PhantasmaJsonAPI::ParseGetRawBlockByHeightResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeGetTransactionByBlockHashAndIndexRequest(JSONBuilder, blockHash, index);
//     bool PhantasmaJsonAPI::ParseGetTransactionByBlockHashAndIndexResponse(JSONValue, Transaction);
//     void PhantasmaJsonAPI::MakeGetAddressTransactionsRequest(JSONBuilder, account, page, pageSize);
//     bool PhantasmaJsonAPI::ParseGetAddressTransactionsResponse(JSONValue, AccountTransactions);
//     void PhantasmaJsonAPI::MakeGetAddressTransactionCountRequest(JSONBuilder, account, chainInput);
//     bool PhantasmaJsonAPI::ParseGetAddressTransactionCountResponse(JSONValue, Int32);
//     void PhantasmaJsonAPI::MakeSendRawTransactionRequest(JSONBuilder, txData);
//     bool PhantasmaJsonAPI::ParseSendRawTransactionResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeInvokeRawScriptRequest(JSONBuilder, chainInput, scriptData);
//     bool PhantasmaJsonAPI::ParseInvokeRawScriptResponse(JSONValue, Script);
//     void PhantasmaJsonAPI::MakeGetTransactionRequest(JSONBuilder, hashText);
//     bool PhantasmaJsonAPI::ParseGetTransactionResponse(JSONValue, Transaction);
//     void PhantasmaJsonAPI::MakeCancelTransactionRequest(JSONBuilder, hashText);
//     bool PhantasmaJsonAPI::ParseCancelTransactionResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeGetChainsRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetChainsResponse(JSONValue, vector<Chain>);
//     void PhantasmaJsonAPI::MakeGetNexusRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetNexusResponse(JSONValue, Nexus);
//     void PhantasmaJsonAPI::MakeGetOrganizationRequest(JSONBuilder, ID);
//     bool PhantasmaJsonAPI::ParseGetOrganizationResponse(JSONValue, Organization);
//     void PhantasmaJsonAPI::MakeGetTokensRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetTokensResponse(JSONValue, vector<Token>);
//     void PhantasmaJsonAPI::MakeGetTokenRequest(JSONBuilder, symbol);
//     bool PhantasmaJsonAPI::ParseGetTokenResponse(JSONValue, Token);
//     void PhantasmaJsonAPI::MakeGetTokenDataRequest(JSONBuilder, symbol, IDtext);
//     bool PhantasmaJsonAPI::ParseGetTokenDataResponse(JSONValue, TokenData);
//     void PhantasmaJsonAPI::MakeGetTokenBalanceRequest(JSONBuilder, account, tokenSymbol, chainInput);
//     bool PhantasmaJsonAPI::ParseGetTokenBalanceResponse(JSONValue, Balance);
//     void PhantasmaJsonAPI::MakeGetAuctionsCountRequest(JSONBuilder, chainAddressOrName, symbol);
//     bool PhantasmaJsonAPI::ParseGetAuctionsCountResponse(JSONValue, Int32);
//     void PhantasmaJsonAPI::MakeGetAuctionsRequest(JSONBuilder, chainAddressOrName, symbol, page, pageSize);
//     bool PhantasmaJsonAPI::ParseGetAuctionsResponse(JSONValue, vector<Auction>);
//     void PhantasmaJsonAPI::MakeGetAuctionRequest(JSONBuilder, chainAddressOrName, symbol, IDtext);
//     bool PhantasmaJsonAPI::ParseGetAuctionResponse(JSONValue, Auction);
//     void PhantasmaJsonAPI::MakeGetArchiveRequest(JSONBuilder, hashText);
//     bool PhantasmaJsonAPI::ParseGetArchiveResponse(JSONValue, Archive);
//     void PhantasmaJsonAPI::MakeWriteArchiveRequest(JSONBuilder, hashText, blockIndex, blockContent);
//     bool PhantasmaJsonAPI::ParseWriteArchiveResponse(JSONValue, bool);
//     void PhantasmaJsonAPI::MakeGetABIRequest(JSONBuilder, chainAddressOrName, contractName);
//     bool PhantasmaJsonAPI::ParseGetABIResponse(JSONValue, ABIContract);
//     void PhantasmaJsonAPI::MakeGetPeersRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetPeersResponse(JSONValue, vector<Peer>);
//     void PhantasmaJsonAPI::MakeRelaySendRequest(JSONBuilder, receiptHex);
//     bool PhantasmaJsonAPI::ParseRelaySendResponse(JSONValue, bool);
//     void PhantasmaJsonAPI::MakeRelayReceiveRequest(JSONBuilder, account);
//     bool PhantasmaJsonAPI::ParseRelayReceiveResponse(JSONValue, vector<Receipt>);
//     void PhantasmaJsonAPI::MakeGetEventsRequest(JSONBuilder, account);
//     bool PhantasmaJsonAPI::ParseGetEventsResponse(JSONValue, vector<Event>);
//     void PhantasmaJsonAPI::MakeGetPlatformsRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetPlatformsResponse(JSONValue, vector<Platform>);
//     void PhantasmaJsonAPI::MakeGetValidatorsRequest(JSONBuilder);
//     bool PhantasmaJsonAPI::ParseGetValidatorsResponse(JSONValue, vector<Validator>);
//     void PhantasmaJsonAPI::MakeSettleSwapRequest(JSONBuilder, sourcePlatform, destPlatform, hashText);
//     bool PhantasmaJsonAPI::ParseSettleSwapResponse(JSONValue, String);
//     void PhantasmaJsonAPI::MakeGetSwapsForAddressRequest(JSONBuilder, account);
//     bool PhantasmaJsonAPI::ParseGetSwapsForAddressResponse(JSONValue, vector<Swap>);
//
//------------------------------------------------------------------------------
// High-level API
//------------------------------------------------------------------------------
//  If you have defined `PHANTASMA_HTTPCLIENT`, then you can construct a 
//   PhantasmaAPI object, which provides a simplified API that hides the 
//   internal JSON messaging.
//
//     PhantasmaAPI phantasmaAPI(httpClient);
//     Account = phantasmaAPI.GetAccount(account, error);
//     String = phantasmaAPI.LookUpName(name, error);
//     Int32 = phantasmaAPI.GetBlockHeight(chainInput, error);
//     Int32 = phantasmaAPI.GetBlockTransactionCountByHash(blockHash, error);
//     Block = phantasmaAPI.GetBlockByHash(blockHash, error);
//     String = phantasmaAPI.GetRawBlockByHash(blockHash, error);
//     Block = phantasmaAPI.GetBlockByHeight(chainInput, height, error);
//     String = phantasmaAPI.GetRawBlockByHeight(chainInput, height, error);
//     Transaction = phantasmaAPI.GetTransactionByBlockHashAndIndex(blockHash, index, error);
//     AccountTransactions = phantasmaAPI.GetAddressTransactions(account, page, pageSize, error);
//     Int32 = phantasmaAPI.GetAddressTransactionCount(account, chainInput, error);
//     String = phantasmaAPI.SendRawTransaction(txData, error);
//     Script = phantasmaAPI.InvokeRawScript(chainInput, scriptData, error);
//     Transaction = phantasmaAPI.GetTransaction(hashText, error);
//     String = phantasmaAPI.CancelTransaction(hashText, error);
//     vector<Chain> = phantasmaAPI.GetChains(error);
//     Nexus = phantasmaAPI.GetNexus(error);
//     Organization = phantasmaAPI.GetOrganization(ID, error);
//     vector<Token> = phantasmaAPI.GetTokens(error);
//     Token = phantasmaAPI.GetToken(symbol, error);
//     TokenData = phantasmaAPI.GetTokenData(symbol, IDtext, error);
//     Balance = phantasmaAPI.GetTokenBalance(account, tokenSymbol, chainInput, error);
//     Int32 = phantasmaAPI.GetAuctionsCount(chainAddressOrName, symbol, error);
//     vector<Auction> = phantasmaAPI.GetAuctions(chainAddressOrName, symbol, page, pageSize, error);
//     Auction = phantasmaAPI.GetAuction(chainAddressOrName, symbol, IDtext, error);
//     Archive = phantasmaAPI.GetArchive(hashText, error);
//     bool = phantasmaAPI.WriteArchive(hashText, blockIndex, blockContent, error);
//     ABIContract = phantasmaAPI.GetABI(chainAddressOrName, contractName, error);
//     vector<Peer> = phantasmaAPI.GetPeers(error);
//     bool = phantasmaAPI.RelaySend(receiptHex, error);
//     vector<Receipt> = phantasmaAPI.RelayReceive(account, error);
//     vector<Event> = phantasmaAPI.GetEvents(account, error);
//     vector<Platform> = phantasmaAPI.GetPlatforms(error);
//     vector<Validator> = phantasmaAPI.GetValidators(error);
//     String = phantasmaAPI.SettleSwap(sourcePlatform, destPlatform, hashText, error);
//     vector<Swap> = phantasmaAPI.GetSwapsForAddress(account, error);
//
//------------------------------------------------------------------------------
// API configuration
//------------------------------------------------------------------------------
// As different C++ projects may use different primitive types, you can use the 
//  following #defines (BEFORE including `phantasma.h`) to override the default types.
//
// |#define                  | typedef                   | Default             | Notes                                                  |
// |-------------------------|---------------------------|---------------------|--------------------------------------------------------|
// |`PHANTASMA_BYTE`         | `phantasma::Byte`         | `uint8_t`           |                                                        |
// |`PHANTASMA_INT32`        | `phantasma::Int32`        | `int32_t`           |                                                        |
// |`PHANTASMA_UINT32`       | `phantasma::UInt32`       | `uint32_t`          |                                                        |
// |`PHANTASMA_INT64`        | `phantasma::Int64`        | `int64_t`           |                                                        |
// |`PHANTASMA_UINT64`       | `phantasma::UInt64`       | `uint64_t`          |                                                        |
// |`PHANTASMA_CHAR`         | `phantasma::Char`         | `char`              | See Unicode section                                    |
// |`PHANTASMA_STRING`       | `phantasma::String`       | `std::string`       | Must support construction from `const phantasma::Char*`|
// |`PHANTASMA_STRINGBUILDER`| `phantasma::StringBuilder`| `std::stringstream` |                                                        |
// |`PHANTASMA_VECTOR`       |                           | `std::vector`       | Must support `push_back` and `size` members            |
// |`PHANTASMA_JSONVALUE`    | `phantasma::JSONValue`    | `std::string_view`  | See JSON and Adaptors section                          |
// |`PHANTASMA_JSONARRAY`    | `phantasma::JSONArray`    | `JSONValue`         | See JSON and Adaptors section                          |
// |`PHANTASMA_JSONDOCUMENT` | `phantasma::JSONDocument` | `std::string`       | See JSON and Adaptors section                          |
// |`PHANTASMA_JSONBUILDER`  | `phantasma::JSONBuilder`  | `std::stringstream`*| See JSON and Adaptors section                          |
// |`PHANTASMA_HTTPCLIENT`   | `phantasma::HttpClient`   |                     | See HTTP and Adaptors section                          |
//
// The behavior of this header can further be modified by using the following 
//  `#defines` (BEFORE including `phantasma.h`)
// 
// |#define                                        | Notes                   |
// |-----------------------------------------------|-------------------------|
// |`PHANTASMA_EXCEPTION(message)`                 | See Exceptions section  |
// |`PHANTASMA_EXCEPTION_MESSAGE(message, String)` | See Exceptions section  |
// |`PHANTASMA_LITERAL(x)`                         | See Unicode section     |
// |`PHANTASMA_FUNCTION`                           | See Integration section |        
// |`PHANTASMA_IMPLEMENTATION`                     | See Integration section |
//
//------------------------------------------------------------------------------
// Integration
//------------------------------------------------------------------------------
// The core of API is provided in the "single header" style to support simple and 
//  flexible integration into your project 
//  (see https://github.com/nothings/single_file_libs / https://en.wikipedia.org/wiki/Header-only).
// The implementation of function bodies will be excluded unless you define
//  `PHANTASMA_IMPLEMENTATION` before including `phantasma.h`.
//
// See the "Extended/Advanced usage" section, below for details on what is excluded
//  from this single header file.
//
// Typical linking:
//  In one CPP file, before including `phantasma.h`:
//   `#define PHANTASMA_IMPLEMENTATION`
// 
// Inline linking:
//  In every CPP file that uses the API, before including `phantasma.h`:
//   `#define PHANTASMA_IMPLEMENTATION`
//   `#define PHANTASMA_FUNCTION inline`
//
// Aside from `PHANTASMA_IMPLEMENTATION` / `PHANTASMA_FUNCTION`, you should take 
//  care to ensure that every other PHANTASMA_* macro is defined to the same value
//  in all of your CPP files that use the phantasma API.
//
//------------------------------------------------------------------------------
// Exceptions
//------------------------------------------------------------------------------
// Support for C++ exceptions is opt-in. Before including `phantasma.h`, define
//  the following to enable exceptions:
//
// `#define PHANTASMA_EXCEPTION_ENABLE`
//
// Alternatively, you can customize the exact type that is thrown by defining:
//
// `#define PHANTASMA_EXCEPTION(message)                 throw std::runtime_error(message)`
// `#define PHANTASMA_EXCEPTION_MESSAGE(message, string) throw std::runtime_error(string)`
//
//------------------------------------------------------------------------------
// Unicode
//------------------------------------------------------------------------------
// To build a wide-character version of the API, define the following before
//  including `phantasma.h`:
//
// `#define PHANTASMA_CHAR          wchar_t`
// `#define PHANTASMA_LITERAL(x)    L ## x`
// `#define PHANTASMA_STRING        std::wstring`
// `#define PHANTASMA_STRINGBUILDER std::wstringstream`
//
// Alternatively, if `_UNICODE` is defined, then the above macros will be defined
//  automatically.
//
// You should also provide a JSON and HTTP library with wide-character support.
//
//------------------------------------------------------------------------------
// Adaptors
//------------------------------------------------------------------------------
// Parts of the Phantasma SDK are designed to plug into external features, such
//  as HTTP communications, JSON encoding and advanced cryptography.
// You can configure the SDK to connect to your own implemenations, or existing
//  libraries.
// To make integration easier, we provide several "adaptor" header files that 
//  contain the required configuration to connect the Phantasma SDK to existing
//  popular open source libraries for different features:
//
// |Library   | Features     | #include file                       | Library URL                             |
// |----------|--------------|-------------------------------------|-----------------------------------------|
// |C++ REST  | HTTP + JSON  | `Adapters/PhantasmaAPI_cpprest.h`   | https://github.com/microsoft/cpprestsdk |
// |libcurl   | HTTP         | `Adapters/PhantasmaAPI_curl.h`      | https://curl.haxx.se/libcurl/           |
// |RapidJSON | JSON         | `Adapters/PhantasmaAPI_rapidjson.h` | http://rapidjson.org/                   |
// |Sodium    | Cryptography | `Adapters/PhantasmaAPI_sodium.h`    | https://libsodium.org                   |
//
//------------------------------------------------------------------------------
// JSON
//------------------------------------------------------------------------------
// This header contains JSON parsing and building code, but it is written to be
//  as simple as possible (approx 200 lines of code) and is not high-performance
//  or highly robust.
//
// It is recommended that you supply another JSON-parsing API, by defining the
//  following macros before including `phantasma.h`:
//  `#define PHANTASMA_JSONVALUE    Your_Json_Value_Type`
//  `#define PHANTASMA_JSONARRAY    Your_Json_Array_Type`
//  `#define PHANTASMA_JSONDOCUMENT Your_JSON_Document_Type`
//  `#define PHANTASMA_JSONBUILDER  Your_Json_Serializer_Type`
//
// **The CPP REST and RapidJSON adaptors implement these macros.**
//
// Also, this header uses the following procedural API to interact with these types.
// If you have supplied your own JSON types, you must implement the following functions:
//
//     namespace phantasma { namespace json {
//     
//        JSONValue Parse(const JSONDocument&);
//     
//        bool      LookupBool(   const JSONValue&, const Char* field, bool& out_error);
//        Int32     LookupInt32(  const JSONValue&, const Char* field, bool& out_error);
//        UInt32    LookupUInt32( const JSONValue&, const Char* field, bool& out_error);
//        String    LookupString( const JSONValue&, const Char* field, bool& out_error);
//        JSONValue LookupValue(  const JSONValue&, const Char* field, bool& out_error);
//        JSONArray LookupArray(  const JSONValue&, const Char* field, bool& out_error);
//        bool      HasField(     const JSONValue&, const Char* field, bool& out_error);
//        bool      HasArrayField(const JSONValue&, const Char* field, bool& out_error);
//     
//        bool      AsBool(       const JSONValue&,                    bool& out_error);
//        Int32     AsInt32(      const JSONValue&,                    bool& out_error);
//        UInt32    AsUInt32(     const JSONValue&,                    bool& out_error);
//        String    AsString(     const JSONValue&,                    bool& out_error);
//        JSONArray AsArray(      const JSONValue&,                    bool& out_error);
//        bool      IsArray(      const JSONValue&,                    bool& out_error);
//        bool      IsObject(     const JSONValue&,                    bool& out_error);
//        
//        int       ArraySize(    const JSONArray&,                    bool& out_error);
//        JSONValue IndexArray(   const JSONArray&, int index,         bool& out_error);
//     
//                               void BeginObject(JSONBuilder&);
//                               void AddString  (JSONBuilder&, const Char* key, const Char* value);
//       template<class... Args> void AddArray   (JSONBuilder&, const Char* key, Args...);
//                               void EndObject  (JSONBuilder&);
//     }}
//
//------------------------------------------------------------------------------
// HTTP
//------------------------------------------------------------------------------
// This header does not contain a HTTP client, nor a dependency on any specific
//  HTTP client library. If you do not supply a HTTP client library, then only
//  the Low-level phantasma API (`PhantasmaJsonAPI`) is available.
//
// To enable the `PhantasmaAPI` class, defining the following macro before 
//  including `phantasma.h`:
// `#define PHANTASMA_HTTPCLIENT   Your_HTTP_Client_Type`
//
// **The CPP REST and libcurl adaptors implement this macro.**
//
// Also, this header uses the following procedural API to interact with this type.
// If you have defined `PHANTASMA_HTTPCLIENT`, you must implement the following,
//  function, which should perform a HTTP POST request and return the result:
//
//     namespace phantasma {
//      JSONDocument HttpPost(HttpClient&, const Char* uri, const JSONBuilder&, PhantasmaError* out_error);
//     }
//
//------------------------------------------------------------------------------
// Extended/Advanced usage
//------------------------------------------------------------------------------
// This header file contains the entirety of the RPC API requried to communicate 
//  with a Phantasma node. If you are not trying to create transactions, this 
//  may be enough for you.
//
// However, for advanced usage, such as creating and signing transactions, much
//  more code is required, including cryptography, N-bit ingeger arithmetic, etc.
// The other header files that are included in this distribution, in sub-folders
//  listed below, provide these extra features:
//
//  |Directory     | Features                                                              |
//  |--------------|-----------------------------------------------------------------------|
//  | Adapters     | Configuration for this library to communicate with 3rd party libraries|
//  | Blockchain   | Transactions                                                          |
//  | Cryptography | Public/Private keys, Signatures, Random numbers, Encryption           |
//  | Numerics     | N-bit integer implementation. Base 16/58 ASCII encoding.              |
//  | Security     | Practical memory protection.                                          |
//
//------------------------------------------------------------------------------
// - Extended/Advanced usage - Security configuration
//------------------------------------------------------------------------------
//   To securely process transactions and private keys, it is strongly advised to 
//   pair the PhantasmaAPI with strong 3rd party security library.
//
//   **The Sodium adaptor implements these macros.**
//   
//  |#define                      |                                                                                                              |
//  |-----------------------------|--------------------------------------------------------------------------------------------------------------|
//  |`PHANTASMA_RANDOMBYTES`      | Fill a memory range with cryptographically secure pseudo-random numbers                                      |
//  |`PHANTASMA_WIPEMEM`          | Fill a memory range with 0's in a way that won't be "optimized away"                                         |
//  |`PHANTASMA_LOCKMEM`          | Pin the memory pages containing this range, and otherwise inform the OS that it contains secrets.            |
//  |`PHANTASMA_UNLOCKMEM`        | Undo the actions of `PHANTASMA_LOCKMEM`, but also fill the memory range with 0's as with `PHANTASMA_WIPEMEM`.|
//  |`PHANTASMA_SECURE_ALLOC`     | Similar to malloc, but should return dedicated pages that can have their access permissions modified.        |
//  |`PHANTASMA_SECURE_FREE`      | Similar to free - used with allocations returned from `PHANTASMA_SECURE_ALLOC`                               |
//  |`PHANTASMA_SECURE_NOACCESS`  | Used with allocations returned from `PHANTASMA_SECURE_ALLOC`. Mark the pages as non-readable.                |
//  |`PHANTASMA_SECURE_READONLY`  | Used with allocations returned from `PHANTASMA_SECURE_ALLOC`. Mark the pages as read only.                   |
//  |`PHANTASMA_SECURE_READWRITE` | Used with allocations returned from `PHANTASMA_SECURE_ALLOC`. Mark the pages as writable.                    |
//
//------------------------------------------------------------------------------
// - Extended/Advanced usage - Cryptography configuration
//------------------------------------------------------------------------------
//  To create or validate transactions, an EdDSA Ed25519 implementation is requied.
//   The libSodium adaptor implements these macros.
//   
//  |#define                                |                                                               |
//  |---------------------------------------|---------------------------------------------------------------|
//  |`PHANTASMA_Ed25519_PublicKeyFromSeed`  | Generate a 32 byte public key from a 32 byte seed.            |
//  |`PHANTASMA_Ed25519_PrivateKeyFromSeed` | Generate a 64 byte public key from a 32 byte seed.            |
//  |`PHANTASMA_Ed25519_SignDetached`       | Generate a 64 byte signature from a message and a private key.|
//  |`PHANTASMA_Ed25519_ValidateDetached`   | Validate a 64 byte signature using a public key.              |
//
//


//------------------------------------------------------------------------------
// API configuration section:
//------------------------------------------------------------------------------

#if !defined(PHANTASMA_STRING) || !defined(PHANTASMA_JSONDOCUMENT) || !defined(PHANTASMA_JSONVALUE)
# include <string>
#endif

#if !defined(PHANTASMA_JSONVALUE) && __cplusplus > 201402L
# include <string_view>
#endif

#if !defined(PHANTASMA_JSONBUILDER) || !defined(PHANTASMA_STRINGBUILDER)
# include <sstream>
#endif

#if !defined(PHANTASMA_VECTOR)
#define PHANTASMA_VECTOR std::vector
# include <vector>
#endif

#if !defined(PHANTASMA_MAP)
#define PHANTASMA_MAP std::map
# include <map>
#endif

#if !defined(PHANTASMA_S32) || !defined(PHANTASMA_U32)
# include <cstdint>
#endif

#if !defined(PHANTASMA_MAX) || !defined(PHANTASMA_COPY) || !defined(PHANTASMA_EQUAL) || !defined(PHANTASMA_SWAP)
# include <algorithm>
#endif

#if defined(_UNICODE) && !defined(PHANTASMA_EXCEPTION) && defined(PHANTASMA_EXCEPTION_ENABLE)
# include <locale>
# include <codecvt>
#endif

#ifndef PHANTASMA_MIN
# ifdef min
#  undef min
# endif
# define PHANTASMA_MIN(a, b) std::min(a, b)
#endif

#ifndef PHANTASMA_MAX
# ifdef max
#  undef max
# endif
# define PHANTASMA_MAX(a, b) std::max(a, b)
#endif

#ifndef PHANTASMA_SWAP
# define PHANTASMA_SWAP(a, b) std::swap(a, b)
#endif 

#ifndef PHANTASMA_COPY
# define PHANTASMA_COPY(src, src_end, dst) std::copy(src, src_end, dst)
#endif

#ifndef PHANTASMA_EQUAL
# define PHANTASMA_EQUAL(a, b, c) std::equal(a, b, c)
#endif

#if !defined(PHANTASMA_TRY)
# if !defined(PHANTASMA_EXCEPTION)
#  define PHANTASMA_TRY         if(true)
#  define PHANTASMA_CATCH( x )  else
#  define PHANTASMA_CATCH_ALL() else
# else
#  define PHANTASMA_TRY		    try
#  define PHANTASMA_CATCH( x )  catch(std::runtime_error& x)
#  define PHANTASMA_CATCH_ALL() catch(...)
# endif
#endif

#if !defined(PHANTASMA_EXCEPTION)
# ifdef PHANTASMA_EXCEPTION_ENABLE
#  ifdef _UNICODE
#   define PHANTASMA_EXCEPTION(literal)                 throw std::runtime_error(literal)
#   define PHANTASMA_EXCEPTION_MESSAGE(literal, string) throw std::runtime_error(std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t>().to_bytes(string))
#  else
#   define PHANTASMA_EXCEPTION(literal)                 throw std::runtime_error(literal)
#   define PHANTASMA_EXCEPTION_MESSAGE(literal, string) throw std::runtime_error(string)
#  endif
# else
#   define PHANTASMA_EXCEPTION(literal)                
#   define PHANTASMA_EXCEPTION_MESSAGE(literal, string)
# endif
#endif

#if !defined(PHANTASMA_LITERAL)
# ifdef _UNICODE
#  define PHANTASMA_LITERAL(x) L ## x
# else
#  define PHANTASMA_LITERAL(x) x
# endif
#endif

#if !defined(PHANTASMA_FUNCTION)
# define PHANTASMA_FUNCTION
#endif

namespace phantasma
{
#ifdef PHANTASMA_CHAR
typedef PHANTASMA_CHAR Char;
#else
# ifdef _UNICODE
typedef wchar_t Char;
# else
typedef char Char;
# endif
#endif

#ifndef PHANTASMA_STRLEN
# ifdef _UNICODE
#  define PHANTASMA_STRLEN(x) wcslen(x)
# else
#  define PHANTASMA_STRLEN(x) strlen(x)
# endif
#endif

#ifndef PHANTASMA_STRTOINT
# ifdef _UNICODE
#  define PHANTASMA_STRTOINT(x) std::wcstoll(x, 0, 10)
# else
#  define PHANTASMA_STRTOINT(x) std::strtoll(x, 0, 10)
# endif
#endif

#ifdef PHANTASMA_BYTE
typedef PHANTASMA_BYTE Byte;
#else
typedef uint8_t Byte;
#endif

typedef PHANTASMA_VECTOR<Byte> ByteArray;

#ifdef PHANTASMA_INT32
typedef PHANTASMA_INT32 Int32;
#else
typedef int32_t Int32;
#endif

#ifdef PHANTASMA_UINT32
typedef PHANTASMA_UINT32 UInt32;
#else
typedef uint32_t UInt32;
#endif

#ifdef PHANTASMA_INT64
typedef PHANTASMA_INT64 Int64;
#else
typedef int64_t Int64;
#endif

#ifdef PHANTASMA_UINT64
typedef PHANTASMA_UINT64 UInt64;
#else
typedef uint64_t UInt64;
#endif

#ifdef PHANTASMA_STRING
typedef PHANTASMA_STRING String;
#else
# ifdef _UNICODE
typedef std::wstring String;
# else
typedef std::string String;
# endif
#endif

#ifdef PHANTASMA_STRINGBUILDER
typedef PHANTASMA_STRINGBUILDER StringBuilder;
#else
# ifdef _UNICODE
typedef std::wstringstream StringBuilder;
# else
typedef std::stringstream StringBuilder;
# endif
#endif

#ifdef PHANTASMA_JSONVALUE
typedef PHANTASMA_JSONVALUE JSONValue;
#elif __cplusplus > 201402L
# ifdef _UNICODE
typedef std::wstring_view JSONValue;
# else
typedef std::string_view JSONValue;
# endif
#else
typedef String JSONValue;
#endif

#ifdef PHANTASMA_JSONARRAY
typedef PHANTASMA_JSONARRAY JSONArray;
#else
typedef JSONValue JSONArray;
#endif

#ifdef PHANTASMA_JSONDOCUMENT
typedef PHANTASMA_JSONDOCUMENT JSONDocument;
#else
typedef String JSONDocument;
#endif


#ifdef PHANTASMA_JSONBUILDER
typedef PHANTASMA_JSONBUILDER JSONBuilder;
#else
struct JSONBuilder // A VERY simple json string builder. Highly recommended that you provide a real JSON library instead!
{
	StringBuilder s;
	bool empty = true;
	operator StringBuilder&() { return s; }
	void AddKey(const Char* key) { if(!empty) { s << ", "; } empty = false; s << '"' << key << "\": "; }
	void AddValues() {}
	void AddValues(const char* arg) { s << '"' << arg << '"'; }
	template<class T> void AddValues(T arg) { s << arg; }
	template<class T, class... Args> void AddValues(T arg0, Args... args) { AddValues(arg0); s << ", "; AddValues(args...); }
	
	void BeginObject() { s << "{"; }
	void AddString(const Char* key, const Char* value) { AddKey(key); s << '"' << value << '"'; }
	template<class... Args> void AddArray(const Char* key, Args... args) { AddKey(key); s << '['; AddValues(args...); s << ']'; }
	void EndObject() { s << "}"; }
};
#endif

#ifdef PHANTASMA_HTTPCLIENT
typedef PHANTASMA_HTTPCLIENT HttpClient;
//JSONDocument HttpPost(HttpClient&, const Char* uri, const JSONBuilder&, PhantasmaError* out_error);
#endif

//If providing a JSON library (highly recommended that you do!), then you must provide these functions yourself:
namespace json
{
#ifndef PHANTASMA_JSONBUILDER
    JSONValue Parse(const JSONDocument&);
	bool LookupBool(const JSONValue&, const Char* field, bool& out_error);
	Int32 LookupInt32(const JSONValue&, const Char* field, bool& out_error);
	UInt32 LookupUInt32(const JSONValue&, const Char* field, bool& out_error);
	String LookupString(const JSONValue&, const Char* field, bool& out_error);
	JSONValue LookupValue(const JSONValue&, const Char* field, bool& out_error);
	JSONArray LookupArray(const JSONValue&, const Char* field, bool& out_error);
	bool HasField(const JSONValue&, const Char* field, bool& out_error);
	bool HasArrayField(const JSONValue&, const Char* field, bool& out_error);
	bool   AsBool(const JSONValue&, bool& out_error);
	Int32  AsInt32(const JSONValue&, bool& out_error);
	UInt32 AsUInt32(const JSONValue&, bool& out_error);
	String AsString(const JSONValue&, bool& out_error);
	JSONArray AsArray(const JSONValue&, bool& out_error);
	bool IsArray(const JSONValue&, bool& out_error);
	bool IsObject(const JSONValue&, bool& out_error);

	int ArraySize(const JSONArray&, bool& out_error);
	JSONValue IndexArray(const JSONArray&, int index, bool& out_error);

	void BeginObject(JSONBuilder&);
	void AddString(JSONBuilder&, const Char* key, const Char* value);
	template<class... Args>
	void AddArray(JSONBuilder&, const Char* key, Args... args);
	void EndObject(JSONBuilder&);
#endif
}

namespace rpc
{
//------------------------------------------------------------------------------
// RPC structures:
//------------------------------------------------------------------------------
struct Token;
struct Chain;
struct Governance;
struct Leaderboard;


struct Balance
{
	String chain;//
	String amount;//
	String symbol;//
	UInt32 decimals;//
	PHANTASMA_VECTOR<String> ids;//
};

struct Interop
{
	String local;//
	String external;//
};

struct Platform
{
	String platform;//
	String chain;//
	String fuel;//
	PHANTASMA_VECTOR<String> tokens;//
	PHANTASMA_VECTOR<Interop> interop;//
};

struct Governance
{
	String name;//
	String value;//
};

struct Organization
{
	String id;//
	String name;//
	PHANTASMA_VECTOR<String> members;//
};

struct Nexus
{
	String name;//
	PHANTASMA_VECTOR<Platform> platforms;//
	PHANTASMA_VECTOR<Token> tokens;//
	PHANTASMA_VECTOR<Chain> chains;//
	PHANTASMA_VECTOR<Governance> governance;//
	PHANTASMA_VECTOR<String> organizations;//
	PHANTASMA_VECTOR<Leaderboard> ses;//
};

struct Stake
{
	String amount;//
	UInt32 time;//
	String unclaimed;//
};

struct Account
{
	String address;//
	String name;//
	Stake stakes;//
	String stake;//
	String unclaimed;//
	String relay;//
	String validator;//
	PHANTASMA_VECTOR<Balance> balances;//
	PHANTASMA_VECTOR<String> txs;//
};

struct Leaderboard
{
	String address;//
	String value;//
};

struct Dapp
{
	String name;//
	String address;//
	String chain;//
};

struct Chain
{
	String name;//
	String address;//
	String parent;//
	UInt32 height;//
	String organization;//
	PHANTASMA_VECTOR<String> contracts;//
	PHANTASMA_VECTOR<String> dapps;//
};

struct Event
{
	String address;//
	String contract;//
	String kind;//
	String data;//
};

struct Oracle
{
	String url;//
	String content;//
};

struct Transaction
{
	String hash;//
	String chainAddress;//
	UInt32 timestamp;//
	Int32 blockHeight;//
	String blockHash;//
	String script;//
	String payload;//
	PHANTASMA_VECTOR<Event> events;//
	String result;//
	String fee;//
};

struct AccountTransactions
{
	String address;//
	PHANTASMA_VECTOR<Transaction> txs;//
};

struct Paginated
{
	UInt32 page;//
	UInt32 pageSize;//
	UInt32 total;//
	UInt32 totalPages;//
	JSONValue result;//
};

struct Block
{
	String hash;//
	String previousHash;//
	UInt32 timestamp;//
	UInt32 height;//
	String chainAddress;//
	UInt32 protocol;//
	PHANTASMA_VECTOR<Transaction> txs;//
	String validatorAddress;//
	String reward;//
	PHANTASMA_VECTOR<Event> events;//
	PHANTASMA_VECTOR<Oracle> oracles;//
};

struct Token
{
	String symbol;//
	String name;//
	Int32 decimals;//
	String currentSupply;//
	String maxSupply;//
	String platform;//
	String hash;//
	String flags;//
};

struct TokenData
{
	String ID;//
	String chainName;//
	String ownerAddress;//
	String ram;//
	String rom;//
	bool forSale;//
};

struct SendRawTx
{
	String hash;//
	String error;//
};

struct Auction
{
	String creatorAddress;//
	String chainAddress;//
	UInt32 startDate;//
	UInt32 endDate;//
	String baseSymbol;//
	String quoteSymbol;//
	String tokenId;//
	String price;//
	String rom;//
	String ram;//
};

struct Script
{
	PHANTASMA_VECTOR<Event> events;//
	String result;//
	PHANTASMA_VECTOR<String> results;//
	PHANTASMA_VECTOR<Oracle> oracles;//
};

struct Archive
{
	String hash;//
	UInt32 size;//
	String flags;//
	String key;//
	Int32 blockCount;//
	PHANTASMA_VECTOR<String> metadata;//
};

struct ABIParameter
{
	String name;//
	String type;//
};

struct ABIMethod
{
	String name;//
	String returnType;//
	PHANTASMA_VECTOR<ABIParameter> parameters;//
};

struct ABIContract
{
	String name;//
	PHANTASMA_VECTOR<ABIMethod> methods;//
};

struct Channel
{
	String creatorAddress;//
	String targetAddress;//
	String name;//
	String chain;//
	UInt32 creationTime;//
	String symbol;//
	String fee;//
	String balance;//
	bool active;//
	Int32 index;//
};

struct Receipt
{
	String nexus;//
	String channel;//
	String index;//
	UInt32 timestamp;//
	String sender;//
	String receiver;//
	String script;//
};

struct Peer
{
	String url;//
	String version;//
	String flags;//
	String fee;//
	UInt32 pow;//
};

struct Validator
{
	String address;//
	String type;//
};

struct Swap
{
	String sourcePlatform;//
	String sourceChain;//
	String sourceHash;//
	String sourceAddress;//
	String destinationPlatform;//
	String destinationChain;//
	String destinationHash;//
	String destinationAddress;//
	String symbol;//
	String value;//
};

struct Error
{
	String message;//
};

struct Authorization
{
	String dapp;//
	String token;//
};

struct WalletBalance
{
	String symbol;//
	String value;//
	Int32 decimals;//
};

struct WalletAccount
{
	String id;//
	String address;//
	String name;//
	String avatar;//
	PHANTASMA_VECTOR<WalletBalance> balances;//
};

struct Invocation
{
	String result;//
};


//------------------------------------------------------------------------------
// Low level RPC API:
//------------------------------------------------------------------------------
struct PhantasmaError
{
	int code = 0;
	String message;

	const static int InvalidJSON = -1;
	const static int HttpError = -2;
	const static int InvalidRpcResponse = -3;
	const static int RpcMessage = -4;
};
inline void OnHttpError(PhantasmaError& err, const Char* msg)
{
	err.code = PhantasmaError::HttpError; 
	if( msg )
		err.message = String(msg);
}

class PhantasmaJsonAPI
{
public:
	static const Char* Uri() { return PHANTASMA_LITERAL("/rpc"); }

	// Returns the account name and balance of given address. 
	static void MakeGetAccountRequest(JSONBuilder&, const Char* account);
	static bool ParseGetAccountResponse(const JSONValue&, Account& out, PhantasmaError* err=0);
	// Returns the address that owns a given name. 
	static void MakeLookUpNameRequest(JSONBuilder&, const Char* name);
	static bool ParseLookUpNameResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Returns the height of a chain. 
	static void MakeGetBlockHeightRequest(JSONBuilder&, const Char* chainInput);
	static bool ParseGetBlockHeightResponse(const JSONValue&, Int32& out, PhantasmaError* err=0);
	// Returns the number of transactions of given block hash or error if given hash is invalid or is not found. 
	static void MakeGetBlockTransactionCountByHashRequest(JSONBuilder&, const Char* blockHash);
	static bool ParseGetBlockTransactionCountByHashResponse(const JSONValue&, Int32& out, PhantasmaError* err=0);
	// Returns information about a block by hash. 
	static void MakeGetBlockByHashRequest(JSONBuilder&, const Char* blockHash);
	static bool ParseGetBlockByHashResponse(const JSONValue&, Block& out, PhantasmaError* err=0);
	// Returns a serialized string, containing information about a block by hash. 
	static void MakeGetRawBlockByHashRequest(JSONBuilder&, const Char* blockHash);
	static bool ParseGetRawBlockByHashResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Returns information about a block by height and chain. 
	static void MakeGetBlockByHeightRequest(JSONBuilder&, const Char* chainInput, UInt32 height);
	static bool ParseGetBlockByHeightResponse(const JSONValue&, Block& out, PhantasmaError* err=0);
	// Returns a serialized string, in hex format, containing information about a block by height and chain. 
	static void MakeGetRawBlockByHeightRequest(JSONBuilder&, const Char* chainInput, UInt32 height);
	static bool ParseGetRawBlockByHeightResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Returns the information about a transaction requested by a block hash and transaction index. 
	static void MakeGetTransactionByBlockHashAndIndexRequest(JSONBuilder&, const Char* blockHash, Int32 index);
	static bool ParseGetTransactionByBlockHashAndIndexResponse(const JSONValue&, Transaction& out, PhantasmaError* err=0);
	// Returns last X transactions of given address. (paginated call)
	static void MakeGetAddressTransactionsRequest(JSONBuilder&, const Char* account, UInt32 page, UInt32 pageSize);
	static bool ParseGetAddressTransactionsResponse(const JSONValue&, AccountTransactions& out, PhantasmaError* err=0);
	// Get number of transactions in a specific address and chain 
	static void MakeGetAddressTransactionCountRequest(JSONBuilder&, const Char* account, const Char* chainInput);
	static bool ParseGetAddressTransactionCountResponse(const JSONValue&, Int32& out, PhantasmaError* err=0);
	// Allows to broadcast a signed operation on the network, but it&apos;s required to build it manually. 
	static void MakeSendRawTransactionRequest(JSONBuilder&, const Char* txData);
	static bool ParseSendRawTransactionResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Allows to invoke script based on network state, without state changes. 
	static void MakeInvokeRawScriptRequest(JSONBuilder&, const Char* chainInput, const Char* scriptData);
	static bool ParseInvokeRawScriptResponse(const JSONValue&, Script& out, PhantasmaError* err=0);
	// Returns information about a transaction by hash. 
	static void MakeGetTransactionRequest(JSONBuilder&, const Char* hashText);
	static bool ParseGetTransactionResponse(const JSONValue&, Transaction& out, PhantasmaError* err=0);
	// Removes a pending transaction from the mempool. 
	static void MakeCancelTransactionRequest(JSONBuilder&, const Char* hashText);
	static bool ParseCancelTransactionResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Returns an array of all chains deployed in Phantasma. 
	static void MakeGetChainsRequest(JSONBuilder&);
	static bool ParseGetChainsResponse(const JSONValue&, PHANTASMA_VECTOR<Chain>& out, PhantasmaError* err=0);
	// Returns info about the nexus. 
	static void MakeGetNexusRequest(JSONBuilder&);
	static bool ParseGetNexusResponse(const JSONValue&, Nexus& out, PhantasmaError* err=0);
	// Returns info about an organization. 
	static void MakeGetOrganizationRequest(JSONBuilder&, const Char* ID);
	static bool ParseGetOrganizationResponse(const JSONValue&, Organization& out, PhantasmaError* err=0);
	// Returns an array of tokens deployed in Phantasma. 
	static void MakeGetTokensRequest(JSONBuilder&);
	static bool ParseGetTokensResponse(const JSONValue&, PHANTASMA_VECTOR<Token>& out, PhantasmaError* err=0);
	// Returns info about a specific token deployed in Phantasma. 
	static void MakeGetTokenRequest(JSONBuilder&, const Char* symbol);
	static bool ParseGetTokenResponse(const JSONValue&, Token& out, PhantasmaError* err=0);
	// Returns data of a non-fungible token, in hexadecimal format. 
	static void MakeGetTokenDataRequest(JSONBuilder&, const Char* symbol, const Char* IDtext);
	static bool ParseGetTokenDataResponse(const JSONValue&, TokenData& out, PhantasmaError* err=0);
	// Returns the balance for a specific token and chain, given an address. 
	static void MakeGetTokenBalanceRequest(JSONBuilder&, const Char* account, const Char* tokenSymbol, const Char* chainInput);
	static bool ParseGetTokenBalanceResponse(const JSONValue&, Balance& out, PhantasmaError* err=0);
	// Returns the number of active auctions. 
	static void MakeGetAuctionsCountRequest(JSONBuilder&, const Char* chainAddressOrName, const Char* symbol);
	static bool ParseGetAuctionsCountResponse(const JSONValue&, Int32& out, PhantasmaError* err=0);
	// Returns the auctions available in the market. (paginated call)
	static void MakeGetAuctionsRequest(JSONBuilder&, const Char* chainAddressOrName, const Char* symbol, UInt32 page, UInt32 pageSize);
	static bool ParseGetAuctionsResponse(const JSONValue&, PHANTASMA_VECTOR<Auction>& out, PhantasmaError* err=0);
	// Returns the auction for a specific token. 
	static void MakeGetAuctionRequest(JSONBuilder&, const Char* chainAddressOrName, const Char* symbol, const Char* IDtext);
	static bool ParseGetAuctionResponse(const JSONValue&, Auction& out, PhantasmaError* err=0);
	// Returns info about a specific archive. 
	static void MakeGetArchiveRequest(JSONBuilder&, const Char* hashText);
	static bool ParseGetArchiveResponse(const JSONValue&, Archive& out, PhantasmaError* err=0);
	// Writes the contents of an incomplete archive. 
	static void MakeWriteArchiveRequest(JSONBuilder&, const Char* hashText, Int32 blockIndex, const Char* blockContent);
	static bool ParseWriteArchiveResponse(const JSONValue&, bool& out, PhantasmaError* err=0);
	// Returns the ABI interface of specific contract. 
	static void MakeGetABIRequest(JSONBuilder&, const Char* chainAddressOrName, const Char* contractName);
	static bool ParseGetABIResponse(const JSONValue&, ABIContract& out, PhantasmaError* err=0);
	// Returns list of known peers. 
	static void MakeGetPeersRequest(JSONBuilder&);
	static bool ParseGetPeersResponse(const JSONValue&, PHANTASMA_VECTOR<Peer>& out, PhantasmaError* err=0);
	// Writes a message to the relay network. 
	static void MakeRelaySendRequest(JSONBuilder&, const Char* receiptHex);
	static bool ParseRelaySendResponse(const JSONValue&, bool& out, PhantasmaError* err=0);
	// Receives messages from the relay network. 
	static void MakeRelayReceiveRequest(JSONBuilder&, const Char* account);
	static bool ParseRelayReceiveResponse(const JSONValue&, PHANTASMA_VECTOR<Receipt>& out, PhantasmaError* err=0);
	// Reads pending messages from the relay network. 
	static void MakeGetEventsRequest(JSONBuilder&, const Char* account);
	static bool ParseGetEventsResponse(const JSONValue&, PHANTASMA_VECTOR<Event>& out, PhantasmaError* err=0);
	// Returns an array of available interop platforms. 
	static void MakeGetPlatformsRequest(JSONBuilder&);
	static bool ParseGetPlatformsResponse(const JSONValue&, PHANTASMA_VECTOR<Platform>& out, PhantasmaError* err=0);
	// Returns an array of available validators. 
	static void MakeGetValidatorsRequest(JSONBuilder&);
	static bool ParseGetValidatorsResponse(const JSONValue&, PHANTASMA_VECTOR<Validator>& out, PhantasmaError* err=0);
	// Tries to settle a pending swap for a specific hash. 
	static void MakeSettleSwapRequest(JSONBuilder&, const Char* sourcePlatform, const Char* destPlatform, const Char* hashText);
	static bool ParseSettleSwapResponse(const JSONValue&, String& out, PhantasmaError* err=0);
	// Returns platform swaps for a specific address. 
	static void MakeGetSwapsForAddressRequest(JSONBuilder&, const Char* account);
	static bool ParseGetSwapsForAddressResponse(const JSONValue&, PHANTASMA_VECTOR<Swap>& out, PhantasmaError* err=0);
	

private:
	static JSONValue CheckResponse(JSONValue response, PhantasmaError& out_error);
	static Balance DeserializeBalance(const JSONValue& json, bool& jsonError);
	static Interop DeserializeInterop(const JSONValue& json, bool& jsonError);
	static Platform DeserializePlatform(const JSONValue& json, bool& jsonError);
	static Governance DeserializeGovernance(const JSONValue& json, bool& jsonError);
	static Organization DeserializeOrganization(const JSONValue& json, bool& jsonError);
	static Nexus DeserializeNexus(const JSONValue& json, bool& jsonError);
	static Stake DeserializeStake(const JSONValue& json, bool& jsonError);
	static Account DeserializeAccount(const JSONValue& json, bool& jsonError);
	static Leaderboard DeserializeLeaderboard(const JSONValue& json, bool& jsonError);
	static Dapp DeserializeDapp(const JSONValue& json, bool& jsonError);
	static Chain DeserializeChain(const JSONValue& json, bool& jsonError);
	static Event DeserializeEvent(const JSONValue& json, bool& jsonError);
	static Oracle DeserializeOracle(const JSONValue& json, bool& jsonError);
	static Transaction DeserializeTransaction(const JSONValue& json, bool& jsonError);
	static AccountTransactions DeserializeAccountTransactions(const JSONValue& json, bool& jsonError);
	static Paginated DeserializePaginated(const JSONValue& json, bool& jsonError);
	static Block DeserializeBlock(const JSONValue& json, bool& jsonError);
	static Token DeserializeToken(const JSONValue& json, bool& jsonError);
	static TokenData DeserializeTokenData(const JSONValue& json, bool& jsonError);
	static SendRawTx DeserializeSendRawTx(const JSONValue& json, bool& jsonError);
	static Auction DeserializeAuction(const JSONValue& json, bool& jsonError);
	static Script DeserializeScript(const JSONValue& json, bool& jsonError);
	static Archive DeserializeArchive(const JSONValue& json, bool& jsonError);
	static ABIParameter DeserializeABIParameter(const JSONValue& json, bool& jsonError);
	static ABIMethod DeserializeABIMethod(const JSONValue& json, bool& jsonError);
	static ABIContract DeserializeABIContract(const JSONValue& json, bool& jsonError);
	static Channel DeserializeChannel(const JSONValue& json, bool& jsonError);
	static Receipt DeserializeReceipt(const JSONValue& json, bool& jsonError);
	static Peer DeserializePeer(const JSONValue& json, bool& jsonError);
	static Validator DeserializeValidator(const JSONValue& json, bool& jsonError);
	static Swap DeserializeSwap(const JSONValue& json, bool& jsonError);
	static Error DeserializeError(const JSONValue& json, bool& jsonError);
	static Authorization DeserializeAuthorization(const JSONValue& json, bool& jsonError);
	static WalletBalance DeserializeWalletBalance(const JSONValue& json, bool& jsonError);
	static WalletAccount DeserializeWalletAccount(const JSONValue& json, bool& jsonError);
	static Invocation DeserializeInvocation(const JSONValue& json, bool& jsonError);
	

	static bool Deserializebool(const JSONValue& json, bool& jsonError);
};

#if defined(PHANTASMA_HTTPCLIENT)
//------------------------------------------------------------------------------
// High level RPC API:
//------------------------------------------------------------------------------
class PhantasmaAPI
{
public:
	PhantasmaAPI(HttpClient& client) // client must have a longer lifetime than this API object
		: m_httpClient(client)
	{}

	// Returns the account name and balance of given address. 
	Account GetAccount(const Char* account, PhantasmaError* out_error = nullptr);
	// Returns the address that owns a given name. 
	String LookUpName(const Char* name, PhantasmaError* out_error = nullptr);
	// Returns the height of a chain. 
	Int32 GetBlockHeight(const Char* chainInput, PhantasmaError* out_error = nullptr);
	// Returns the number of transactions of given block hash or error if given hash is invalid or is not found. 
	Int32 GetBlockTransactionCountByHash(const Char* blockHash, PhantasmaError* out_error = nullptr);
	// Returns information about a block by hash. 
	Block GetBlockByHash(const Char* blockHash, PhantasmaError* out_error = nullptr);
	// Returns a serialized string, containing information about a block by hash. 
	String GetRawBlockByHash(const Char* blockHash, PhantasmaError* out_error = nullptr);
	// Returns information about a block by height and chain. 
	Block GetBlockByHeight(const Char* chainInput, UInt32 height, PhantasmaError* out_error = nullptr);
	// Returns a serialized string, in hex format, containing information about a block by height and chain. 
	String GetRawBlockByHeight(const Char* chainInput, UInt32 height, PhantasmaError* out_error = nullptr);
	// Returns the information about a transaction requested by a block hash and transaction index. 
	Transaction GetTransactionByBlockHashAndIndex(const Char* blockHash, Int32 index, PhantasmaError* out_error = nullptr);
	// Returns last X transactions of given address. (paginated call)
	AccountTransactions GetAddressTransactions(const Char* account, UInt32 page, UInt32 pageSize, PhantasmaError* out_error = nullptr);
	// Get number of transactions in a specific address and chain 
	Int32 GetAddressTransactionCount(const Char* account, const Char* chainInput, PhantasmaError* out_error = nullptr);
	// Allows to broadcast a signed operation on the network, but it&apos;s required to build it manually. 
	String SendRawTransaction(const Char* txData, PhantasmaError* out_error = nullptr);
	// Allows to invoke script based on network state, without state changes. 
	Script InvokeRawScript(const Char* chainInput, const Char* scriptData, PhantasmaError* out_error = nullptr);
	// Returns information about a transaction by hash. 
	Transaction GetTransaction(const Char* hashText, PhantasmaError* out_error = nullptr);
	// Removes a pending transaction from the mempool. 
	String CancelTransaction(const Char* hashText, PhantasmaError* out_error = nullptr);
	// Returns an array of all chains deployed in Phantasma. 
	PHANTASMA_VECTOR<Chain> GetChains(PhantasmaError* out_error = nullptr);
	// Returns info about the nexus. 
	Nexus GetNexus(PhantasmaError* out_error = nullptr);
	// Returns info about an organization. 
	Organization GetOrganization(const Char* ID, PhantasmaError* out_error = nullptr);
	// Returns an array of tokens deployed in Phantasma. 
	PHANTASMA_VECTOR<Token> GetTokens(PhantasmaError* out_error = nullptr);
	// Returns info about a specific token deployed in Phantasma. 
	Token GetToken(const Char* symbol, PhantasmaError* out_error = nullptr);
	// Returns data of a non-fungible token, in hexadecimal format. 
	TokenData GetTokenData(const Char* symbol, const Char* IDtext, PhantasmaError* out_error = nullptr);
	// Returns the balance for a specific token and chain, given an address. 
	Balance GetTokenBalance(const Char* account, const Char* tokenSymbol, const Char* chainInput, PhantasmaError* out_error = nullptr);
	// Returns the number of active auctions. 
	Int32 GetAuctionsCount(const Char* chainAddressOrName, const Char* symbol, PhantasmaError* out_error = nullptr);
	// Returns the auctions available in the market. (paginated call)
	PHANTASMA_VECTOR<Auction> GetAuctions(const Char* chainAddressOrName, const Char* symbol, UInt32 page, UInt32 pageSize, PhantasmaError* out_error = nullptr);
	// Returns the auction for a specific token. 
	Auction GetAuction(const Char* chainAddressOrName, const Char* symbol, const Char* IDtext, PhantasmaError* out_error = nullptr);
	// Returns info about a specific archive. 
	Archive GetArchive(const Char* hashText, PhantasmaError* out_error = nullptr);
	// Writes the contents of an incomplete archive. 
	bool WriteArchive(const Char* hashText, Int32 blockIndex, const Char* blockContent, PhantasmaError* out_error = nullptr);
	// Returns the ABI interface of specific contract. 
	ABIContract GetABI(const Char* chainAddressOrName, const Char* contractName, PhantasmaError* out_error = nullptr);
	// Returns list of known peers. 
	PHANTASMA_VECTOR<Peer> GetPeers(PhantasmaError* out_error = nullptr);
	// Writes a message to the relay network. 
	bool RelaySend(const Char* receiptHex, PhantasmaError* out_error = nullptr);
	// Receives messages from the relay network. 
	PHANTASMA_VECTOR<Receipt> RelayReceive(const Char* account, PhantasmaError* out_error = nullptr);
	// Reads pending messages from the relay network. 
	PHANTASMA_VECTOR<Event> GetEvents(const Char* account, PhantasmaError* out_error = nullptr);
	// Returns an array of available interop platforms. 
	PHANTASMA_VECTOR<Platform> GetPlatforms(PhantasmaError* out_error = nullptr);
	// Returns an array of available validators. 
	PHANTASMA_VECTOR<Validator> GetValidators(PhantasmaError* out_error = nullptr);
	// Tries to settle a pending swap for a specific hash. 
	String SettleSwap(const Char* sourcePlatform, const Char* destPlatform, const Char* hashText, PhantasmaError* out_error = nullptr);
	// Returns platform swaps for a specific address. 
	PHANTASMA_VECTOR<Swap> GetSwapsForAddress(const Char* account, PhantasmaError* out_error = nullptr);
	
private:
	HttpClient& m_httpClient;
};
#endif
	
#if defined(PHANTASMA_IMPLEMENTATION)
//------------------------------------------------------------------------------
// RPC API implementation details:
//------------------------------------------------------------------------------
PHANTASMA_FUNCTION bool PhantasmaJsonAPI::Deserializebool(const JSONValue& value, bool& jsonErr)
{
	return json::AsBool(value, jsonErr);
}


PHANTASMA_FUNCTION Balance PhantasmaJsonAPI::DeserializeBalance(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<String> idsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("ids"), jsonErr))
	{
		const JSONArray& idsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("ids"), jsonErr);
		int size = json::ArraySize(idsJsonArray, jsonErr);
		idsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			idsVector.push_back(json::AsString(json::IndexArray(idsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Balance { 
		json::LookupString(value, PHANTASMA_LITERAL("chain"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("amount"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("symbol"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("decimals"), jsonErr), 
		idsVector
	};
}

PHANTASMA_FUNCTION Interop PhantasmaJsonAPI::DeserializeInterop(const JSONValue& value, bool& jsonErr)
{ 	
	return Interop { 
		json::LookupString(value, PHANTASMA_LITERAL("local"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("external"), jsonErr)
	};
}

PHANTASMA_FUNCTION Platform PhantasmaJsonAPI::DeserializePlatform(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<String> tokensVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("tokens"), jsonErr))
	{
		const JSONArray& tokensJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("tokens"), jsonErr);
		int size = json::ArraySize(tokensJsonArray, jsonErr);
		tokensVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			tokensVector.push_back(json::AsString(json::IndexArray(tokensJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Interop> interopVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("interop"), jsonErr))
	{
		const JSONArray& interopJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("interop"), jsonErr);
		int size = json::ArraySize(interopJsonArray, jsonErr);
		interopVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			interopVector.push_back(DeserializeInterop(json::IndexArray(interopJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Platform { 
		json::LookupString(value, PHANTASMA_LITERAL("platform"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chain"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("fuel"), jsonErr), 
		tokensVector, 
		interopVector
	};
}

PHANTASMA_FUNCTION Governance PhantasmaJsonAPI::DeserializeGovernance(const JSONValue& value, bool& jsonErr)
{ 	
	return Governance { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("value"), jsonErr)
	};
}

PHANTASMA_FUNCTION Organization PhantasmaJsonAPI::DeserializeOrganization(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<String> membersVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("members"), jsonErr))
	{
		const JSONArray& membersJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("members"), jsonErr);
		int size = json::ArraySize(membersJsonArray, jsonErr);
		membersVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			membersVector.push_back(json::AsString(json::IndexArray(membersJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Organization { 
		json::LookupString(value, PHANTASMA_LITERAL("id"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		membersVector
	};
}

PHANTASMA_FUNCTION Nexus PhantasmaJsonAPI::DeserializeNexus(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Platform> platformsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("platforms"), jsonErr))
	{
		const JSONArray& platformsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("platforms"), jsonErr);
		int size = json::ArraySize(platformsJsonArray, jsonErr);
		platformsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			platformsVector.push_back(DeserializePlatform(json::IndexArray(platformsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Token> tokensVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("tokens"), jsonErr))
	{
		const JSONArray& tokensJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("tokens"), jsonErr);
		int size = json::ArraySize(tokensJsonArray, jsonErr);
		tokensVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			tokensVector.push_back(DeserializeToken(json::IndexArray(tokensJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Chain> chainsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("chains"), jsonErr))
	{
		const JSONArray& chainsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("chains"), jsonErr);
		int size = json::ArraySize(chainsJsonArray, jsonErr);
		chainsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			chainsVector.push_back(DeserializeChain(json::IndexArray(chainsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Governance> governanceVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("governance"), jsonErr))
	{
		const JSONArray& governanceJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("governance"), jsonErr);
		int size = json::ArraySize(governanceJsonArray, jsonErr);
		governanceVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			governanceVector.push_back(DeserializeGovernance(json::IndexArray(governanceJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<String> organizationsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("organizations"), jsonErr))
	{
		const JSONArray& organizationsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("organizations"), jsonErr);
		int size = json::ArraySize(organizationsJsonArray, jsonErr);
		organizationsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			organizationsVector.push_back(json::AsString(json::IndexArray(organizationsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Leaderboard> sesVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("ses"), jsonErr))
	{
		const JSONArray& sesJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("ses"), jsonErr);
		int size = json::ArraySize(sesJsonArray, jsonErr);
		sesVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			sesVector.push_back(DeserializeLeaderboard(json::IndexArray(sesJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Nexus { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		platformsVector, 
		tokensVector, 
		chainsVector, 
		governanceVector, 
		organizationsVector, 
		sesVector
	};
}

PHANTASMA_FUNCTION Stake PhantasmaJsonAPI::DeserializeStake(const JSONValue& value, bool& jsonErr)
{ 	
	return Stake { 
		json::LookupString(value, PHANTASMA_LITERAL("amount"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("time"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("unclaimed"), jsonErr)
	};
}

PHANTASMA_FUNCTION Account PhantasmaJsonAPI::DeserializeAccount(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Balance> balancesVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("balances"), jsonErr))
	{
		const JSONArray& balancesJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("balances"), jsonErr);
		int size = json::ArraySize(balancesJsonArray, jsonErr);
		balancesVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			balancesVector.push_back(DeserializeBalance(json::IndexArray(balancesJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<String> txsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("txs"), jsonErr))
	{
		const JSONArray& txsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("txs"), jsonErr);
		int size = json::ArraySize(txsJsonArray, jsonErr);
		txsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			txsVector.push_back(json::AsString(json::IndexArray(txsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Account { 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		DeserializeStake(json::LookupValue(value, PHANTASMA_LITERAL("stakes"), jsonErr), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("stake"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("unclaimed"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("relay"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("validator"), jsonErr), 
		balancesVector, 
		txsVector
	};
}

PHANTASMA_FUNCTION Leaderboard PhantasmaJsonAPI::DeserializeLeaderboard(const JSONValue& value, bool& jsonErr)
{ 	
	return Leaderboard { 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("value"), jsonErr)
	};
}

PHANTASMA_FUNCTION Dapp PhantasmaJsonAPI::DeserializeDapp(const JSONValue& value, bool& jsonErr)
{ 	
	return Dapp { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chain"), jsonErr)
	};
}

PHANTASMA_FUNCTION Chain PhantasmaJsonAPI::DeserializeChain(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<String> contractsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("contracts"), jsonErr))
	{
		const JSONArray& contractsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("contracts"), jsonErr);
		int size = json::ArraySize(contractsJsonArray, jsonErr);
		contractsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			contractsVector.push_back(json::AsString(json::IndexArray(contractsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<String> dappsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("dapps"), jsonErr))
	{
		const JSONArray& dappsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("dapps"), jsonErr);
		int size = json::ArraySize(dappsJsonArray, jsonErr);
		dappsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			dappsVector.push_back(json::AsString(json::IndexArray(dappsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Chain { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("parent"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("height"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("organization"), jsonErr), 
		contractsVector, 
		dappsVector
	};
}

PHANTASMA_FUNCTION Event PhantasmaJsonAPI::DeserializeEvent(const JSONValue& value, bool& jsonErr)
{ 	
	return Event { 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("contract"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("kind"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("data"), jsonErr)
	};
}

PHANTASMA_FUNCTION Oracle PhantasmaJsonAPI::DeserializeOracle(const JSONValue& value, bool& jsonErr)
{ 	
	return Oracle { 
		json::LookupString(value, PHANTASMA_LITERAL("url"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("content"), jsonErr)
	};
}

PHANTASMA_FUNCTION Transaction PhantasmaJsonAPI::DeserializeTransaction(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Event> eventsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("events"), jsonErr))
	{
		const JSONArray& eventsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("events"), jsonErr);
		int size = json::ArraySize(eventsJsonArray, jsonErr);
		eventsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			eventsVector.push_back(DeserializeEvent(json::IndexArray(eventsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Transaction { 
		json::LookupString(value, PHANTASMA_LITERAL("hash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chainAddress"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("timestamp"), jsonErr), 
		json::LookupInt32(value, PHANTASMA_LITERAL("blockHeight"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("blockHash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("script"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("payload"), jsonErr), 
		eventsVector, 
		json::LookupString(value, PHANTASMA_LITERAL("result"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("fee"), jsonErr)
	};
}

PHANTASMA_FUNCTION AccountTransactions PhantasmaJsonAPI::DeserializeAccountTransactions(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Transaction> txsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("txs"), jsonErr))
	{
		const JSONArray& txsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("txs"), jsonErr);
		int size = json::ArraySize(txsJsonArray, jsonErr);
		txsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			txsVector.push_back(DeserializeTransaction(json::IndexArray(txsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return AccountTransactions { 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		txsVector
	};
}

PHANTASMA_FUNCTION Paginated PhantasmaJsonAPI::DeserializePaginated(const JSONValue& value, bool& jsonErr)
{ 	
	return Paginated { 
		json::LookupUInt32(value, PHANTASMA_LITERAL("page"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("pageSize"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("total"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("totalPages"), jsonErr), 
		json::LookupValue(value, PHANTASMA_LITERAL("result"), jsonErr)
	};
}

PHANTASMA_FUNCTION Block PhantasmaJsonAPI::DeserializeBlock(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Transaction> txsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("txs"), jsonErr))
	{
		const JSONArray& txsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("txs"), jsonErr);
		int size = json::ArraySize(txsJsonArray, jsonErr);
		txsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			txsVector.push_back(DeserializeTransaction(json::IndexArray(txsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Event> eventsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("events"), jsonErr))
	{
		const JSONArray& eventsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("events"), jsonErr);
		int size = json::ArraySize(eventsJsonArray, jsonErr);
		eventsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			eventsVector.push_back(DeserializeEvent(json::IndexArray(eventsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Oracle> oraclesVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("oracles"), jsonErr))
	{
		const JSONArray& oraclesJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("oracles"), jsonErr);
		int size = json::ArraySize(oraclesJsonArray, jsonErr);
		oraclesVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			oraclesVector.push_back(DeserializeOracle(json::IndexArray(oraclesJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Block { 
		json::LookupString(value, PHANTASMA_LITERAL("hash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("previousHash"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("timestamp"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("height"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chainAddress"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("protocol"), jsonErr), 
		txsVector, 
		json::LookupString(value, PHANTASMA_LITERAL("validatorAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("reward"), jsonErr), 
		eventsVector, 
		oraclesVector
	};
}

PHANTASMA_FUNCTION Token PhantasmaJsonAPI::DeserializeToken(const JSONValue& value, bool& jsonErr)
{ 	
	return Token { 
		json::LookupString(value, PHANTASMA_LITERAL("symbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupInt32(value, PHANTASMA_LITERAL("decimals"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("currentSupply"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("maxSupply"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("platform"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("hash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("flags"), jsonErr)
	};
}

PHANTASMA_FUNCTION TokenData PhantasmaJsonAPI::DeserializeTokenData(const JSONValue& value, bool& jsonErr)
{ 	
	return TokenData { 
		json::LookupString(value, PHANTASMA_LITERAL("ID"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chainName"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("ownerAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("ram"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("rom"), jsonErr), 
		json::LookupBool(value, PHANTASMA_LITERAL("forSale"), jsonErr)
	};
}

PHANTASMA_FUNCTION SendRawTx PhantasmaJsonAPI::DeserializeSendRawTx(const JSONValue& value, bool& jsonErr)
{ 	
	return SendRawTx { 
		json::LookupString(value, PHANTASMA_LITERAL("hash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("error"), jsonErr)
	};
}

PHANTASMA_FUNCTION Auction PhantasmaJsonAPI::DeserializeAuction(const JSONValue& value, bool& jsonErr)
{ 	
	return Auction { 
		json::LookupString(value, PHANTASMA_LITERAL("creatorAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chainAddress"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("startDate"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("endDate"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("baseSymbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("quoteSymbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("tokenId"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("price"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("rom"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("ram"), jsonErr)
	};
}

PHANTASMA_FUNCTION Script PhantasmaJsonAPI::DeserializeScript(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<Event> eventsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("events"), jsonErr))
	{
		const JSONArray& eventsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("events"), jsonErr);
		int size = json::ArraySize(eventsJsonArray, jsonErr);
		eventsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			eventsVector.push_back(DeserializeEvent(json::IndexArray(eventsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<String> resultsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("results"), jsonErr))
	{
		const JSONArray& resultsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("results"), jsonErr);
		int size = json::ArraySize(resultsJsonArray, jsonErr);
		resultsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			resultsVector.push_back(json::AsString(json::IndexArray(resultsJsonArray, i, jsonErr), jsonErr));
		}
	}
	PHANTASMA_VECTOR<Oracle> oraclesVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("oracles"), jsonErr))
	{
		const JSONArray& oraclesJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("oracles"), jsonErr);
		int size = json::ArraySize(oraclesJsonArray, jsonErr);
		oraclesVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			oraclesVector.push_back(DeserializeOracle(json::IndexArray(oraclesJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Script { 
		eventsVector, 
		json::LookupString(value, PHANTASMA_LITERAL("result"), jsonErr), 
		resultsVector, 
		oraclesVector
	};
}

PHANTASMA_FUNCTION Archive PhantasmaJsonAPI::DeserializeArchive(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<String> metadataVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("metadata"), jsonErr))
	{
		const JSONArray& metadataJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("metadata"), jsonErr);
		int size = json::ArraySize(metadataJsonArray, jsonErr);
		metadataVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			metadataVector.push_back(json::AsString(json::IndexArray(metadataJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return Archive { 
		json::LookupString(value, PHANTASMA_LITERAL("hash"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("size"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("flags"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("key"), jsonErr), 
		json::LookupInt32(value, PHANTASMA_LITERAL("blockCount"), jsonErr), 
		metadataVector
	};
}

PHANTASMA_FUNCTION ABIParameter PhantasmaJsonAPI::DeserializeABIParameter(const JSONValue& value, bool& jsonErr)
{ 	
	return ABIParameter { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("type"), jsonErr)
	};
}

PHANTASMA_FUNCTION ABIMethod PhantasmaJsonAPI::DeserializeABIMethod(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<ABIParameter> parametersVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("parameters"), jsonErr))
	{
		const JSONArray& parametersJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("parameters"), jsonErr);
		int size = json::ArraySize(parametersJsonArray, jsonErr);
		parametersVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			parametersVector.push_back(DeserializeABIParameter(json::IndexArray(parametersJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return ABIMethod { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("returnType"), jsonErr), 
		parametersVector
	};
}

PHANTASMA_FUNCTION ABIContract PhantasmaJsonAPI::DeserializeABIContract(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<ABIMethod> methodsVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("methods"), jsonErr))
	{
		const JSONArray& methodsJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("methods"), jsonErr);
		int size = json::ArraySize(methodsJsonArray, jsonErr);
		methodsVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			methodsVector.push_back(DeserializeABIMethod(json::IndexArray(methodsJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return ABIContract { 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		methodsVector
	};
}

PHANTASMA_FUNCTION Channel PhantasmaJsonAPI::DeserializeChannel(const JSONValue& value, bool& jsonErr)
{ 	
	return Channel { 
		json::LookupString(value, PHANTASMA_LITERAL("creatorAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("targetAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("chain"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("creationTime"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("symbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("fee"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("balance"), jsonErr), 
		json::LookupBool(value, PHANTASMA_LITERAL("active"), jsonErr), 
		json::LookupInt32(value, PHANTASMA_LITERAL("index"), jsonErr)
	};
}

PHANTASMA_FUNCTION Receipt PhantasmaJsonAPI::DeserializeReceipt(const JSONValue& value, bool& jsonErr)
{ 	
	return Receipt { 
		json::LookupString(value, PHANTASMA_LITERAL("nexus"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("channel"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("index"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("timestamp"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("sender"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("receiver"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("script"), jsonErr)
	};
}

PHANTASMA_FUNCTION Peer PhantasmaJsonAPI::DeserializePeer(const JSONValue& value, bool& jsonErr)
{ 	
	return Peer { 
		json::LookupString(value, PHANTASMA_LITERAL("url"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("version"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("flags"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("fee"), jsonErr), 
		json::LookupUInt32(value, PHANTASMA_LITERAL("pow"), jsonErr)
	};
}

PHANTASMA_FUNCTION Validator PhantasmaJsonAPI::DeserializeValidator(const JSONValue& value, bool& jsonErr)
{ 	
	return Validator { 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("type"), jsonErr)
	};
}

PHANTASMA_FUNCTION Swap PhantasmaJsonAPI::DeserializeSwap(const JSONValue& value, bool& jsonErr)
{ 	
	return Swap { 
		json::LookupString(value, PHANTASMA_LITERAL("sourcePlatform"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("sourceChain"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("sourceHash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("sourceAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("destinationPlatform"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("destinationChain"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("destinationHash"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("destinationAddress"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("symbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("value"), jsonErr)
	};
}

PHANTASMA_FUNCTION Error PhantasmaJsonAPI::DeserializeError(const JSONValue& value, bool& jsonErr)
{ 	
	return Error { 
		json::LookupString(value, PHANTASMA_LITERAL("message"), jsonErr)
	};
}

PHANTASMA_FUNCTION Authorization PhantasmaJsonAPI::DeserializeAuthorization(const JSONValue& value, bool& jsonErr)
{ 	
	return Authorization { 
		json::LookupString(value, PHANTASMA_LITERAL("dapp"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("token"), jsonErr)
	};
}

PHANTASMA_FUNCTION WalletBalance PhantasmaJsonAPI::DeserializeWalletBalance(const JSONValue& value, bool& jsonErr)
{ 	
	return WalletBalance { 
		json::LookupString(value, PHANTASMA_LITERAL("symbol"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("value"), jsonErr), 
		json::LookupInt32(value, PHANTASMA_LITERAL("decimals"), jsonErr)
	};
}

PHANTASMA_FUNCTION WalletAccount PhantasmaJsonAPI::DeserializeWalletAccount(const JSONValue& value, bool& jsonErr)
{ 
	PHANTASMA_VECTOR<WalletBalance> balancesVector;
	if(json::HasArrayField(value, PHANTASMA_LITERAL("balances"), jsonErr))
	{
		const JSONArray& balancesJsonArray = json::LookupArray(value, PHANTASMA_LITERAL("balances"), jsonErr);
		int size = json::ArraySize(balancesJsonArray, jsonErr);
		balancesVector.reserve(size);
		for(int i = 0; i < size; ++i)
		{
			balancesVector.push_back(DeserializeWalletBalance(json::IndexArray(balancesJsonArray, i, jsonErr), jsonErr));
		}
	}	
	return WalletAccount { 
		json::LookupString(value, PHANTASMA_LITERAL("id"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("address"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("name"), jsonErr), 
		json::LookupString(value, PHANTASMA_LITERAL("avatar"), jsonErr), 
		balancesVector
	};
}

PHANTASMA_FUNCTION Invocation PhantasmaJsonAPI::DeserializeInvocation(const JSONValue& value, bool& jsonErr)
{ 	
	return Invocation { 
		json::LookupString(value, PHANTASMA_LITERAL("result"), jsonErr)
	};
}



PHANTASMA_FUNCTION JSONValue PhantasmaJsonAPI::CheckResponse(JSONValue response, PhantasmaError& out_error)
{
	bool jsonErr = false;
	if( !json::IsObject(response, jsonErr) || jsonErr )
	{
		PHANTASMA_EXCEPTION("Failed to parse JSON");
		out_error.code = PhantasmaError::InvalidRpcResponse;
		return response;
	}
	if( json::HasField(response, PHANTASMA_LITERAL("error"), jsonErr) )
	{
		const JSONValue& error = json::LookupValue(response, PHANTASMA_LITERAL("error"), jsonErr);
		int code = PhantasmaError::RpcMessage;
		String msg;
		if(json::IsObject(error, jsonErr))
		{
			msg = json::LookupString(error, PHANTASMA_LITERAL("message"), jsonErr);
			code = json::LookupInt32(error, PHANTASMA_LITERAL("code"), jsonErr);
		}
		else
		{
			msg = json::LookupString(response, PHANTASMA_LITERAL("error"), jsonErr);
		}
		PHANTASMA_EXCEPTION_MESSAGE("Server returned error", msg);
		out_error.message = msg;
		out_error.code = code;
		return response;
	}
	if( !json::HasField(response, PHANTASMA_LITERAL("result"), jsonErr) || jsonErr )
	{
		PHANTASMA_EXCEPTION("Malformed response: No \"result\" node on the JSON body");
		out_error.code = PhantasmaError::InvalidRpcResponse;
		return response;
	}
	JSONValue result = json::LookupValue(response, PHANTASMA_LITERAL("result"), jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return result;
}


// Returns the account name and balance of given address. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAccountRequest(JSONBuilder& request, const Char* account)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAccount"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAccountResponse(const JSONValue& _jsonResponse, Account& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeAccount(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the address that owns a given name. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeLookUpNameRequest(JSONBuilder& request, const Char* name)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("lookUpName"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), name);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseLookUpNameResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the height of a chain. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetBlockHeightRequest(JSONBuilder& request, const Char* chainInput)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getBlockHeight"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainInput);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetBlockHeightResponse(const JSONValue& _jsonResponse, Int32& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsInt32(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the number of transactions of given block hash or error if given hash is invalid or is not found. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetBlockTransactionCountByHashRequest(JSONBuilder& request, const Char* blockHash)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getBlockTransactionCountByHash"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), blockHash);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetBlockTransactionCountByHashResponse(const JSONValue& _jsonResponse, Int32& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsInt32(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns information about a block by hash. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetBlockByHashRequest(JSONBuilder& request, const Char* blockHash)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getBlockByHash"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), blockHash);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetBlockByHashResponse(const JSONValue& _jsonResponse, Block& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeBlock(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns a serialized string, containing information about a block by hash. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetRawBlockByHashRequest(JSONBuilder& request, const Char* blockHash)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getRawBlockByHash"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), blockHash);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetRawBlockByHashResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns information about a block by height and chain. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetBlockByHeightRequest(JSONBuilder& request, const Char* chainInput, UInt32 height)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getBlockByHeight"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainInput, height);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetBlockByHeightResponse(const JSONValue& _jsonResponse, Block& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeBlock(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns a serialized string, in hex format, containing information about a block by height and chain. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetRawBlockByHeightRequest(JSONBuilder& request, const Char* chainInput, UInt32 height)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getRawBlockByHeight"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainInput, height);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetRawBlockByHeightResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the information about a transaction requested by a block hash and transaction index. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTransactionByBlockHashAndIndexRequest(JSONBuilder& request, const Char* blockHash, Int32 index)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getTransactionByBlockHashAndIndex"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), blockHash, index);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTransactionByBlockHashAndIndexResponse(const JSONValue& _jsonResponse, Transaction& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeTransaction(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns last X transactions of given address. (Paginated)
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAddressTransactionsRequest(JSONBuilder& request, const Char* account, UInt32 page, UInt32 pageSize)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAddressTransactions"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account, page, pageSize);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAddressTransactionsResponse(const JSONValue& _jsonResponse, AccountTransactions& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	Paginated pageStruct = DeserializePaginated(jsonResponse, jsonErr);
	output = DeserializeAccountTransactions(pageStruct.result, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}

// Get number of transactions in a specific address and chain 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAddressTransactionCountRequest(JSONBuilder& request, const Char* account, const Char* chainInput)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAddressTransactionCount"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account, chainInput);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAddressTransactionCountResponse(const JSONValue& _jsonResponse, Int32& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsInt32(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Allows to broadcast a signed operation on the network, but it&apos;s required to build it manually. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeSendRawTransactionRequest(JSONBuilder& request, const Char* txData)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("sendRawTransaction"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), txData);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseSendRawTransactionResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Allows to invoke script based on network state, without state changes. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeInvokeRawScriptRequest(JSONBuilder& request, const Char* chainInput, const Char* scriptData)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("invokeRawScript"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainInput, scriptData);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseInvokeRawScriptResponse(const JSONValue& _jsonResponse, Script& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeScript(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns information about a transaction by hash. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTransactionRequest(JSONBuilder& request, const Char* hashText)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getTransaction"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), hashText);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTransactionResponse(const JSONValue& _jsonResponse, Transaction& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeTransaction(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Removes a pending transaction from the mempool. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeCancelTransactionRequest(JSONBuilder& request, const Char* hashText)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("cancelTransaction"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), hashText);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseCancelTransactionResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns an array of all chains deployed in Phantasma. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetChainsRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getChains"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetChainsResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Chain>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeChain(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns info about the nexus. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetNexusRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getNexus"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetNexusResponse(const JSONValue& _jsonResponse, Nexus& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeNexus(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns info about an organization. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetOrganizationRequest(JSONBuilder& request, const Char* ID)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getOrganization"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), ID);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetOrganizationResponse(const JSONValue& _jsonResponse, Organization& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeOrganization(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns an array of tokens deployed in Phantasma. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTokensRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getTokens"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTokensResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Token>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeToken(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns info about a specific token deployed in Phantasma. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTokenRequest(JSONBuilder& request, const Char* symbol)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getToken"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), symbol);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTokenResponse(const JSONValue& _jsonResponse, Token& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeToken(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns data of a non-fungible token, in hexadecimal format. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTokenDataRequest(JSONBuilder& request, const Char* symbol, const Char* IDtext)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getTokenData"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), symbol, IDtext);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTokenDataResponse(const JSONValue& _jsonResponse, TokenData& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeTokenData(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the balance for a specific token and chain, given an address. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetTokenBalanceRequest(JSONBuilder& request, const Char* account, const Char* tokenSymbol, const Char* chainInput)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getTokenBalance"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account, tokenSymbol, chainInput);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetTokenBalanceResponse(const JSONValue& _jsonResponse, Balance& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeBalance(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the number of active auctions. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAuctionsCountRequest(JSONBuilder& request, const Char* chainAddressOrName, const Char* symbol)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAuctionsCount"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainAddressOrName, symbol);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAuctionsCountResponse(const JSONValue& _jsonResponse, Int32& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsInt32(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the auctions available in the market. (Paginated)
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAuctionsRequest(JSONBuilder& request, const Char* chainAddressOrName, const Char* symbol, UInt32 page, UInt32 pageSize)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAuctions"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainAddressOrName, symbol, page, pageSize);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAuctionsResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Auction>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	Paginated pageStruct = DeserializePaginated(jsonResponse, jsonErr);
	if(!json::IsArray(pageStruct.result, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 
	const JSONArray& pages = json::AsArray(pageStruct.result, jsonErr);
	int size = json::ArraySize(pages, jsonErr);
	output.reserve(size);
	for(int i = 0; i < size; ++i)
	{
		output.push_back(DeserializeAuction(json::IndexArray(pages, i, jsonErr), jsonErr));
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}

// Returns the auction for a specific token. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetAuctionRequest(JSONBuilder& request, const Char* chainAddressOrName, const Char* symbol, const Char* IDtext)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getAuction"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainAddressOrName, symbol, IDtext);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetAuctionResponse(const JSONValue& _jsonResponse, Auction& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeAuction(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns info about a specific archive. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetArchiveRequest(JSONBuilder& request, const Char* hashText)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getArchive"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), hashText);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetArchiveResponse(const JSONValue& _jsonResponse, Archive& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeArchive(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Writes the contents of an incomplete archive. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeWriteArchiveRequest(JSONBuilder& request, const Char* hashText, Int32 blockIndex, const Char* blockContent)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("writeArchive"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), hashText, blockIndex, blockContent);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseWriteArchiveResponse(const JSONValue& _jsonResponse, bool& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = Deserializebool(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns the ABI interface of specific contract. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetABIRequest(JSONBuilder& request, const Char* chainAddressOrName, const Char* contractName)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getABI"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), chainAddressOrName, contractName);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetABIResponse(const JSONValue& _jsonResponse, ABIContract& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = DeserializeABIContract(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns list of known peers. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetPeersRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getPeers"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetPeersResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Peer>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializePeer(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Writes a message to the relay network. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeRelaySendRequest(JSONBuilder& request, const Char* receiptHex)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("relaySend"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), receiptHex);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseRelaySendResponse(const JSONValue& _jsonResponse, bool& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = Deserializebool(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Receives messages from the relay network. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeRelayReceiveRequest(JSONBuilder& request, const Char* account)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("relayReceive"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseRelayReceiveResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Receipt>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeReceipt(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Reads pending messages from the relay network. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetEventsRequest(JSONBuilder& request, const Char* account)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getEvents"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetEventsResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Event>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeEvent(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns an array of available interop platforms. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetPlatformsRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getPlatforms"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetPlatformsResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Platform>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializePlatform(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns an array of available validators. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetValidatorsRequest(JSONBuilder& request)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getValidators"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"));
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetValidatorsResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Validator>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeValidator(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Tries to settle a pending swap for a specific hash. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeSettleSwapRequest(JSONBuilder& request, const Char* sourcePlatform, const Char* destPlatform, const Char* hashText)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("settleSwap"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), sourcePlatform, destPlatform, hashText);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseSettleSwapResponse(const JSONValue& _jsonResponse, String& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	output = json::AsString(jsonResponse, jsonErr);
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


// Returns platform swaps for a specific address. 
PHANTASMA_FUNCTION void PhantasmaJsonAPI::MakeGetSwapsForAddressRequest(JSONBuilder& request, const Char* account)
{
	json::BeginObject(request);
	json::AddString(request, PHANTASMA_LITERAL("jsonrpc"), PHANTASMA_LITERAL("2.0"));
	json::AddString(request, PHANTASMA_LITERAL("method"), PHANTASMA_LITERAL("getSwapsForAddress"));
	json::AddString(request, PHANTASMA_LITERAL("id"), PHANTASMA_LITERAL("1"));
	json::AddArray(request, PHANTASMA_LITERAL("params"), account);
	json::EndObject(request);
}

PHANTASMA_FUNCTION bool PhantasmaJsonAPI::ParseGetSwapsForAddressResponse(const JSONValue& _jsonResponse, PHANTASMA_VECTOR<Swap>& output, PhantasmaError* pout_err)
{
	PhantasmaError err_dummy;
	PhantasmaError& out_error = pout_err ? *pout_err : err_dummy;
	JSONValue jsonResponse = PhantasmaJsonAPI::CheckResponse(_jsonResponse, out_error);
	if( out_error.code )
		return false;
	bool jsonErr = false;
	if (!json::IsArray(jsonResponse, jsonErr))
	{ 
		PHANTASMA_EXCEPTION("Malformed response: No JSON array on the \"result\" node");
		out_error.code = PhantasmaError::InvalidJSON;
		return false;
	} 

	const JSONArray& resultArray = json::AsArray(jsonResponse, jsonErr);
	int resultArraySize = json::ArraySize(resultArray, jsonErr);
	output.reserve(resultArraySize);
	for(int i = 0; i < resultArraySize; ++i)
	{
		output.push_back(DeserializeSwap(json::IndexArray(resultArray, i, jsonErr), jsonErr));
		if( jsonErr || out_error.code )
			break;
	}
	if( !out_error.code && jsonErr )
		out_error.code = PhantasmaError::InvalidJSON;
	return out_error.code == 0;
}


	
#if defined(PHANTASMA_HTTPCLIENT)

PHANTASMA_FUNCTION Account PhantasmaAPI::GetAccount(const Char* account, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAccountRequest(request, account);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Account output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAccountResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::LookUpName(const Char* name, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeLookUpNameRequest(request, name);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseLookUpNameResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Int32 PhantasmaAPI::GetBlockHeight(const Char* chainInput, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetBlockHeightRequest(request, chainInput);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Int32 output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetBlockHeightResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Int32 PhantasmaAPI::GetBlockTransactionCountByHash(const Char* blockHash, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetBlockTransactionCountByHashRequest(request, blockHash);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Int32 output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetBlockTransactionCountByHashResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Block PhantasmaAPI::GetBlockByHash(const Char* blockHash, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetBlockByHashRequest(request, blockHash);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Block output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetBlockByHashResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::GetRawBlockByHash(const Char* blockHash, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetRawBlockByHashRequest(request, blockHash);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetRawBlockByHashResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Block PhantasmaAPI::GetBlockByHeight(const Char* chainInput, UInt32 height, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetBlockByHeightRequest(request, chainInput, height);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Block output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetBlockByHeightResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::GetRawBlockByHeight(const Char* chainInput, UInt32 height, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetRawBlockByHeightRequest(request, chainInput, height);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetRawBlockByHeightResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Transaction PhantasmaAPI::GetTransactionByBlockHashAndIndex(const Char* blockHash, Int32 index, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTransactionByBlockHashAndIndexRequest(request, blockHash, index);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Transaction output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTransactionByBlockHashAndIndexResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION AccountTransactions PhantasmaAPI::GetAddressTransactions(const Char* account, UInt32 page, UInt32 pageSize, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAddressTransactionsRequest(request, account, page, pageSize);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	AccountTransactions output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAddressTransactionsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Int32 PhantasmaAPI::GetAddressTransactionCount(const Char* account, const Char* chainInput, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAddressTransactionCountRequest(request, account, chainInput);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Int32 output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAddressTransactionCountResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::SendRawTransaction(const Char* txData, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeSendRawTransactionRequest(request, txData);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseSendRawTransactionResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Script PhantasmaAPI::InvokeRawScript(const Char* chainInput, const Char* scriptData, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeInvokeRawScriptRequest(request, chainInput, scriptData);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Script output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseInvokeRawScriptResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Transaction PhantasmaAPI::GetTransaction(const Char* hashText, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTransactionRequest(request, hashText);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Transaction output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTransactionResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::CancelTransaction(const Char* hashText, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeCancelTransactionRequest(request, hashText);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseCancelTransactionResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Chain> PhantasmaAPI::GetChains(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetChainsRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Chain> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetChainsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Nexus PhantasmaAPI::GetNexus(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetNexusRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Nexus output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetNexusResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Organization PhantasmaAPI::GetOrganization(const Char* ID, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetOrganizationRequest(request, ID);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Organization output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetOrganizationResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Token> PhantasmaAPI::GetTokens(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTokensRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Token> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTokensResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Token PhantasmaAPI::GetToken(const Char* symbol, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTokenRequest(request, symbol);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Token output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTokenResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION TokenData PhantasmaAPI::GetTokenData(const Char* symbol, const Char* IDtext, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTokenDataRequest(request, symbol, IDtext);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	TokenData output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTokenDataResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Balance PhantasmaAPI::GetTokenBalance(const Char* account, const Char* tokenSymbol, const Char* chainInput, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetTokenBalanceRequest(request, account, tokenSymbol, chainInput);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Balance output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetTokenBalanceResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Int32 PhantasmaAPI::GetAuctionsCount(const Char* chainAddressOrName, const Char* symbol, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAuctionsCountRequest(request, chainAddressOrName, symbol);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Int32 output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAuctionsCountResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Auction> PhantasmaAPI::GetAuctions(const Char* chainAddressOrName, const Char* symbol, UInt32 page, UInt32 pageSize, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAuctionsRequest(request, chainAddressOrName, symbol, page, pageSize);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Auction> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAuctionsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Auction PhantasmaAPI::GetAuction(const Char* chainAddressOrName, const Char* symbol, const Char* IDtext, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetAuctionRequest(request, chainAddressOrName, symbol, IDtext);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Auction output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetAuctionResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION Archive PhantasmaAPI::GetArchive(const Char* hashText, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetArchiveRequest(request, hashText);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	Archive output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetArchiveResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION bool PhantasmaAPI::WriteArchive(const Char* hashText, Int32 blockIndex, const Char* blockContent, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeWriteArchiveRequest(request, hashText, blockIndex, blockContent);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	bool output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseWriteArchiveResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION ABIContract PhantasmaAPI::GetABI(const Char* chainAddressOrName, const Char* contractName, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetABIRequest(request, chainAddressOrName, contractName);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	ABIContract output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetABIResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Peer> PhantasmaAPI::GetPeers(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetPeersRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Peer> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetPeersResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION bool PhantasmaAPI::RelaySend(const Char* receiptHex, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeRelaySendRequest(request, receiptHex);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	bool output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseRelaySendResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Receipt> PhantasmaAPI::RelayReceive(const Char* account, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeRelayReceiveRequest(request, account);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Receipt> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseRelayReceiveResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Event> PhantasmaAPI::GetEvents(const Char* account, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetEventsRequest(request, account);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Event> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetEventsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Platform> PhantasmaAPI::GetPlatforms(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetPlatformsRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Platform> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetPlatformsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Validator> PhantasmaAPI::GetValidators(PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetValidatorsRequest(request);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Validator> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetValidatorsResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION String PhantasmaAPI::SettleSwap(const Char* sourcePlatform, const Char* destPlatform, const Char* hashText, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeSettleSwapRequest(request, sourcePlatform, destPlatform, hashText);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	String output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseSettleSwapResponse(json::Parse(response), output, out_error);
	return output;
}

PHANTASMA_FUNCTION PHANTASMA_VECTOR<Swap> PhantasmaAPI::GetSwapsForAddress(const Char* account, PhantasmaError* out_error)
{
	JSONBuilder request;
	PhantasmaJsonAPI::MakeGetSwapsForAddressRequest(request, account);
	const JSONDocument& response = HttpPost(m_httpClient, PhantasmaJsonAPI::Uri(), request, out_error);
	PHANTASMA_VECTOR<Swap> output;
	if( !out_error || out_error->code == 0 )
		PhantasmaJsonAPI::ParseGetSwapsForAddressResponse(json::Parse(response), output, out_error);
	return output;
}

#endif
}

namespace json
{
#ifndef PHANTASMA_JSONVALUE
//------------------------------------------------------------------------------
// Built-in JSON parsing library:
//------------------------------------------------------------------------------
    JSONValue Parse(const JSONDocument& doc) { return doc; }

	inline size_t SkipNumber(const JSONValue& v, size_t i, bool& out_error)
	{
		size_t j = v.find_first_not_of(PHANTASMA_LITERAL("+-0123456789.eE"), i);
		if( i==j ) { PHANTASMA_EXCEPTION("Invalid Number"); out_error = true; return i+1; }
		return j;
	}
	inline size_t SkipString(const JSONValue& v, size_t i, bool& out_error)
	{
		if( v[i] != '"' ) { PHANTASMA_EXCEPTION("Invalid String"); out_error = true; return i+1; }
		for(++i; i<v.size();)
		{
			i =  v.find_first_of(PHANTASMA_LITERAL("\"\\"), i);
			if( i == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated String"); out_error = true; return i; }
			if( v[i] == '"' ) { break; }
			if( i+1 < v.size() )
			{
				switch(v[i+1])
				{
				case '\\': case 'b': case 'f': case 'n': case 'r': case 't': case '"': i = i+2; continue;
				case 'u': i = i+6; continue;
				}
			}
			PHANTASMA_EXCEPTION("Invalid Escape sequence"); out_error = true; ++i;
		}
		return i == JSONValue::npos ? i : i+1;
	}
	inline size_t SkipBoolNull(const JSONValue& v, size_t i, bool& out_error)
	{
		switch(v[i])
		{
		case 'f': if(v.compare(i, 5, PHANTASMA_LITERAL("false"))) { break; } return i+5;
		case 't': if(v.compare(i, 4, PHANTASMA_LITERAL("true")))  { break; } return i+4;
		case 'n': if(v.compare(i, 4, PHANTASMA_LITERAL("null")))  { break; } return i+4;
		}
		PHANTASMA_EXCEPTION("Invalid Value"); out_error = true; return i+1;
	}
	inline size_t SkipObject(const JSONValue& v, size_t i, bool& out_error);
	inline size_t SkipArray(const JSONValue& v, size_t i, bool& out_error)
	{
		if( v[i] != '[' ) { PHANTASMA_EXCEPTION("Invalid Array"); out_error = true; return i+1; }
		++i;
		for(; i<v.size();)
		{
			i = v.find_first_not_of(PHANTASMA_LITERAL(", \t\r\n\f\b"), i);
			if( i == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated array"); out_error = true; return i; }
			switch( v[i] )
			{
			case ']': return i+1;
			case '{': i = SkipObject(v, i, out_error); break;
			case '[': i = SkipArray(v, i, out_error); break;
			case '"': i = SkipString(v, i, out_error); break;
			case 't': case 'f': case 'n': i = SkipBoolNull(v, i, out_error); break;
			default:  i = SkipNumber(v, i, out_error); break;
			}
		}
		PHANTASMA_EXCEPTION("Unterminated array");
		out_error = true;
		return i == JSONValue::npos ? i : i+1;
	}
	inline size_t SkipObject(const JSONValue& v, size_t i, bool& out_error)
	{
		if( v[i] != '{' ) { PHANTASMA_EXCEPTION("Invalid object"); out_error = true; return i+1; }
		for(; i<v.size();)
		{
			size_t keyBegin = v.find_first_of(PHANTASMA_LITERAL("\"}"), i);
			if( keyBegin == JSONValue::npos || v[keyBegin] == '}' ) { break; }//no more keys
			size_t keyEnd = v.find_first_of('"', keyBegin+1);
			if( keyEnd == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated string"); out_error = true; break; }
			size_t valueBegin = v.find_first_not_of(PHANTASMA_LITERAL(" \t\r\n\f\b:"), keyEnd+1);
			if( valueBegin == JSONValue::npos ) { PHANTASMA_EXCEPTION("No value following object key"); out_error = true; break; }
			Char value0 = v[valueBegin];
			switch(value0)
			{
			case '{': i = SkipObject(v, valueBegin, out_error); break;
			case '[': i = SkipArray(v, valueBegin, out_error); break;
			case '"': i = SkipString(v, valueBegin, out_error); break;
			case 't': case 'f': case 'n': i = SkipBoolNull(v, valueBegin, out_error); break;
			default:  i = SkipNumber(v, valueBegin, out_error); break;
			}
		}
		return i == JSONValue::npos ? i : i+1;
	}

	PHANTASMA_FUNCTION bool LookupBool(const JSONValue& v, const Char* field, bool& out_error)       { return AsBool( LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION Int32 LookupInt32(const JSONValue& v, const Char* field, bool& out_error)     { return AsInt32( LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION UInt32 LookupUInt32(const JSONValue& v, const Char* field, bool& out_error)   { return AsUInt32(LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION String LookupString(const JSONValue& v, const Char* field, bool& out_error)   { return AsString(LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION JSONArray LookupArray(const JSONValue& v, const Char* field, bool& out_error) { return AsArray(LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION bool HasField(const JSONValue& v, const Char* field, bool& out_error)         { return JSONValue() != LookupValue(v, field, out_error); }
	PHANTASMA_FUNCTION bool HasArrayField(const JSONValue& v, const Char* field, bool& out_error)    { return IsArray(LookupValue(v, field, out_error), out_error); }
	PHANTASMA_FUNCTION JSONValue LookupValue(const JSONValue& v, const Char* field, bool& out_error)
	{
		if( v.length() < 1 || v[0] != '{' ) { out_error = true; return JSONValue(); }
		size_t fieldLen = PHANTASMA_STRLEN(field);
		for(size_t i=0; i<v.size();)
		{
			size_t keyBegin = v.find_first_of(PHANTASMA_LITERAL("\"}"), i);
			if( keyBegin == JSONValue::npos || v[keyBegin] == '}' ) { break; }//no more keys
			++keyBegin;
			size_t keyEnd = v.find_first_of('"', keyBegin);
			if( keyEnd == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated string"); out_error = true; break; }
			size_t valueBegin = v.find_first_not_of(PHANTASMA_LITERAL(" \t\r\n\f\b:"), keyEnd+1);
			if( valueBegin == JSONValue::npos ) { PHANTASMA_EXCEPTION("No value following object key"); out_error = true; break; }
			size_t keyLen = keyEnd-keyBegin;
			bool correctKey = fieldLen == keyLen && 0==v.compare(keyBegin, keyLen, field);
			if( correctKey )
				return v.substr(valueBegin);//should really be using string views if this was a serious json parser...
			Char value0 = v[valueBegin];
			switch(value0)
			{
			case '{': i = SkipObject(v, valueBegin, out_error); break;
			case '[': i = SkipArray( v, valueBegin, out_error); break;
			case '"': i = SkipString(v, valueBegin, out_error); break;
			case 't': case 'f': case 'n': i = SkipBoolNull(v, valueBegin, out_error); break;
			default:  i = SkipNumber(v, valueBegin, out_error); break;
			}
		}
		return JSONValue();
	}
	PHANTASMA_FUNCTION bool AsBool(const JSONValue& v, bool& out_error)
	{
		if( v.length() < 1 ) { out_error = true; return false; }
		switch(v[0])
		{
		default: PHANTASMA_EXCEPTION("Casting non-bool value to bool"); out_error = true;
		case 'f': return false;
		case 't': return true;
		}
	}
	PHANTASMA_FUNCTION Int32  AsInt32(const JSONValue& v, bool& out_error)
	{
		const Char* numeric = PHANTASMA_LITERAL("-0123456789");
		size_t begin = v.find_first_of(numeric, 0);
		if( begin != 0 ) { PHANTASMA_EXCEPTION("Invalid number"); out_error = true; return 0; }
		size_t pos = v.find_first_not_of(numeric, 0);
		if( pos == 0 ) { PHANTASMA_EXCEPTION("Invalid number"); out_error = true; return 0; }
		JSONValue n = pos == JSONValue::npos ? v : v.substr(0, pos);
		return (Int32)PHANTASMA_STRTOINT(n.data());
	}
	PHANTASMA_FUNCTION UInt32 AsUInt32(const JSONValue& v, bool& out_error) { return (UInt32)AsInt32(v, out_error); }
	PHANTASMA_FUNCTION String AsString(const JSONValue& v, bool& out_error)
	{
		if( v.length() < 1 || v[0] != '"' ) { PHANTASMA_EXCEPTION("Casting non-string value to string"); out_error = true; return String(); }
		size_t pos = v.find('"', 1);
		if( pos == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated string"); out_error = true; return String(); }
		return String(v.substr(1, pos-1));
	}
	PHANTASMA_FUNCTION JSONArray AsArray(const JSONValue& v, bool& out_error) { if(!IsArray(v, out_error)) { PHANTASMA_EXCEPTION("Casting non-array value to array"); out_error = true; } return v; }
	PHANTASMA_FUNCTION bool IsArray(const JSONValue& v, bool& out_error)
	{
		if( v.length() < 1 ) { out_error = true; return false; }
		return v[0] == '[';
	}
	PHANTASMA_FUNCTION bool IsObject(const JSONValue& v, bool& out_error)
	{
		if( v.length() < 1 ) { out_error = true; return false; }
		return v[0] == '{';
	}

	PHANTASMA_FUNCTION int ArraySize(const JSONArray& v, bool& out_error)
	{
		if( v[0] != '[' ) { PHANTASMA_EXCEPTION("Invalid Array"); out_error = true; return 0; }
		int count = 0;
		for(size_t i=1; i<v.size();)
		{
			i = v.find_first_not_of(PHANTASMA_LITERAL(", \t\r\n\f\b"), i);
			if( i == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated array"); out_error = true; return count; }
			switch( v[i] )
			{
			case ']': return count;
			case '{': i = SkipObject(v, i, out_error); count++; break;
			case '[': i = SkipArray(v, i, out_error);  count++; break;
			case '"': i = SkipString(v, i, out_error); count++; break;
			case 't': case 'f': case 'n': i = SkipBoolNull(v, i, out_error); break;
			default:  i = SkipNumber(v, i, out_error); count++; break;
			}
		}
		return count;
	}
	PHANTASMA_FUNCTION JSONValue IndexArray(const JSONArray& v, int index, bool& out_error)
	{
		if( v[0] != '[' ) { PHANTASMA_EXCEPTION("Invalid Array"); out_error = true; return JSONValue(); }
		int count = 0;
		for(size_t i=1; i<v.size();)
		{
			i = v.find_first_not_of(PHANTASMA_LITERAL(", \t\r\n\f\b"), i);
			if( i == JSONValue::npos ) { PHANTASMA_EXCEPTION("Unterminated array"); out_error = true; return JSONValue(); }
			if( count == index )
				return v.substr(i);
			switch( v[i] )
			{
			case ']': goto err;
			case '{': i = SkipObject(v, i, out_error); count++; break;
			case '[': i = SkipArray(v, i, out_error);  count++; break;
			case '"': i = SkipString(v, i, out_error); count++; break;
			case 't': case 'f': case 'n': i = SkipBoolNull(v, i, out_error); break;
			default:  i = SkipNumber(v, i, out_error); count++; break;
			}
		}
	err:
		PHANTASMA_EXCEPTION("Array index out of bounds"); 
		out_error = true;
		return JSONValue();
	}
#endif
#ifndef PHANTASMA_JSONBUILDER
	PHANTASMA_FUNCTION void BeginObject(JSONBuilder& b)                                   { b.BeginObject(); }
	PHANTASMA_FUNCTION void AddString(JSONBuilder& b, const Char* key, const Char* value) { b.AddString(key, value); }
	template<class... Args>
	void AddArray(JSONBuilder& b, const Char* key, Args... args)                          { b.AddArray(key, args...); }
	PHANTASMA_FUNCTION void EndObject(JSONBuilder& b)                                     { b.EndObject(); }
#endif
#endif
}
}
#endif
